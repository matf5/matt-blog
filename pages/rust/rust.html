<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>cargo.lock | matt的前端之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/matt-blog/cainiao.jpg">
    <meta name="description" content="matt的前端之路">
    
    <link rel="preload" href="/matt-blog/assets/css/0.styles.67df34d8.css" as="style"><link rel="preload" href="/matt-blog/assets/js/app.ffdfc81f.js" as="script"><link rel="preload" href="/matt-blog/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/matt-blog/assets/js/1.f8bb34da.js" as="script"><link rel="preload" href="/matt-blog/assets/js/29.e94060ac.js" as="script"><link rel="prefetch" href="/matt-blog/assets/js/10.fde088a2.js"><link rel="prefetch" href="/matt-blog/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/matt-blog/assets/js/12.27d4f152.js"><link rel="prefetch" href="/matt-blog/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/matt-blog/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/matt-blog/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/matt-blog/assets/js/16.85253907.js"><link rel="prefetch" href="/matt-blog/assets/js/17.c2838453.js"><link rel="prefetch" href="/matt-blog/assets/js/18.3256f17f.js"><link rel="prefetch" href="/matt-blog/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/matt-blog/assets/js/20.0d880388.js"><link rel="prefetch" href="/matt-blog/assets/js/21.33b300c9.js"><link rel="prefetch" href="/matt-blog/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/matt-blog/assets/js/23.4db98f57.js"><link rel="prefetch" href="/matt-blog/assets/js/24.d445e64c.js"><link rel="prefetch" href="/matt-blog/assets/js/25.ddddf3ac.js"><link rel="prefetch" href="/matt-blog/assets/js/26.7d944ff2.js"><link rel="prefetch" href="/matt-blog/assets/js/27.f36e0827.js"><link rel="prefetch" href="/matt-blog/assets/js/28.3f37ce9e.js"><link rel="prefetch" href="/matt-blog/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/matt-blog/assets/js/30.c745aff1.js"><link rel="prefetch" href="/matt-blog/assets/js/31.e16206ce.js"><link rel="prefetch" href="/matt-blog/assets/js/32.082e47b7.js"><link rel="prefetch" href="/matt-blog/assets/js/33.771afc1b.js"><link rel="prefetch" href="/matt-blog/assets/js/4.45665f8a.js"><link rel="prefetch" href="/matt-blog/assets/js/5.7098d77a.js"><link rel="prefetch" href="/matt-blog/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/matt-blog/assets/js/7.6a854e57.js"><link rel="prefetch" href="/matt-blog/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/matt-blog/assets/css/0.styles.67df34d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/matt-blog/" class="home-link router-link-active"><img src="/matt-blog/cainiao.jpg" alt="matt的前端之路" class="logo"> <span class="site-name can-hide">matt的前端之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/matt-blog/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/matt-blog/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hybrid</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>performance</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-native</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>rust</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/matt-blog/pages/rust/rust.html" aria-current="page" class="active sidebar-link">learn rust</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#mut-和shadow的区别" class="sidebar-link">mut 和shadow的区别</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#整数类型" class="sidebar-link">整数类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#浮点类型" class="sidebar-link">浮点类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#布尔类型" class="sidebar-link">布尔类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#字符类型" class="sidebar-link">字符类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#符合类型" class="sidebar-link">符合类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#语句" class="sidebar-link">语句</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#表达式" class="sidebar-link">表达式</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#if表达式" class="sidebar-link">if表达式</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#loop" class="sidebar-link">loop</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#while" class="sidebar-link">while</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#for" class="sidebar-link">for</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#string类型" class="sidebar-link">String类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#数据交互方式一-move" class="sidebar-link">数据交互方式一: Move</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#数据交互方式二-clone" class="sidebar-link">数据交互方式二: Clone</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#只在栈上的数据-拷贝" class="sidebar-link">只在栈上的数据: 拷贝</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#所有权与函数" class="sidebar-link">所有权与函数</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#返回值与作用域" class="sidebar-link">返回值与作用域</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#可变引用" class="sidebar-link">可变引用</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#悬垂引用-dangling-references" class="sidebar-link">悬垂引用（Dangling References）</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#引用的规则" class="sidebar-link">引用的规则</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#解引用" class="sidebar-link">解引用 (*)</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#字符串" class="sidebar-link">字符串</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#其他类型" class="sidebar-link">其他类型</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#tuple-struct" class="sidebar-link">tuple struct</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#trait-功能" class="sidebar-link">trait 功能</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#dbg" class="sidebar-link">dbg!</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#方法语法" class="sidebar-link">方法语法</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#option" class="sidebar-link">option</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#match" class="sidebar-link">match</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#匹配options" class="sidebar-link">匹配Options</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#other和" class="sidebar-link">other和_</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#if-let" class="sidebar-link">if let</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#包和crate" class="sidebar-link">包和crate</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#模块" class="sidebar-link">模块</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#路径" class="sidebar-link">路径</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#use" class="sidebar-link">use</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#嵌套路径" class="sidebar-link">嵌套路径</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#读取" class="sidebar-link">读取</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#遍历" class="sidebar-link">遍历</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#枚举" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#新建" class="sidebar-link">新建</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#更新" class="sidebar-link">更新</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#拼接" class="sidebar-link">拼接</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#内部表现" class="sidebar-link">内部表现</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#slice" class="sidebar-link">slice</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#遍历-2" class="sidebar-link">遍历</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#所有权" class="sidebar-link">所有权</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#访问" class="sidebar-link">访问</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#插入" class="sidebar-link">插入</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#更新-2" class="sidebar-link">更新</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#根据旧值更新" class="sidebar-link">根据旧值更新</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#result" class="sidebar-link">Result</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#unwrap-和expect" class="sidebar-link">unwrap 和expect</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#传播错误" class="sidebar-link">传播错误</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#传播简写" class="sidebar-link">传播简写 ?</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#函数-2" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#结构体" class="sidebar-link">结构体</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#枚举-2" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#单态化" class="sidebar-link">单态化</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#类型实现trait" class="sidebar-link">类型实现trait</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#默认实现" class="sidebar-link">默认实现</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#trait作为参数" class="sidebar-link">trait作为参数</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#指定多个trait" class="sidebar-link">+ 指定多个trait</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#where" class="sidebar-link">where</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#return" class="sidebar-link">return</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#example" class="sidebar-link">example</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#借用检查器" class="sidebar-link">借用检查器</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#生命周期标注语法" class="sidebar-link">生命周期标注语法</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#lazy-avaluation" class="sidebar-link">lazy avaluation</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#捕获环境" class="sidebar-link">捕获环境</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#move" class="sidebar-link">move</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#map" class="sidebar-link">map</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#闭包获取环境" class="sidebar-link">闭包获取环境</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#解引用强制转换" class="sidebar-link">解引用强制转换</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/rust/rust.html#解引用强制转换-2" class="sidebar-link">解引用强制转换</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="cargo-lock"><a href="#cargo-lock" class="header-anchor">#</a> cargo.lock</h1> <ol><li>首次安装时自动使用当前大版本的最新版本</li> <li>一旦lock存在, 后续每次都是使用lock中的版本</li> <li>需要更新可以用cargo update</li></ol> <h1 id="view-doc"><a href="#view-doc" class="header-anchor">#</a> view doc</h1> <p>cargo doc --open</p> <h1 id="mismatched-type"><a href="#mismatched-type" class="header-anchor">#</a> mismatched type</h1> <p>Rust有静态强类型系统, 可以进行类型推断</p> <h1 id="shadow"><a href="#shadow" class="header-anchor">#</a> shadow</h1> <p>rust允许新值覆盖之前的值</p> <h2 id="mut-和shadow的区别"><a href="#mut-和shadow的区别" class="header-anchor">#</a> mut 和shadow的区别</h2> <p>shadow可以重复使用相同的变量名称</p> <h1 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h1> <h2 id="整数类型"><a href="#整数类型" class="header-anchor">#</a> 整数类型</h2> <p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240425160121.png" alt="20240425160121"></p> <p>默认会使用i32</p> <h2 id="浮点类型"><a href="#浮点类型" class="header-anchor">#</a> 浮点类型</h2> <h3 id="单精度-f32"><a href="#单精度-f32" class="header-anchor">#</a> 单精度 f32</h3> <h3 id="双精度-f64-默认"><a href="#双精度-f64-默认" class="header-anchor">#</a> 双精度 f64(默认)</h3> <h2 id="布尔类型"><a href="#布尔类型" class="header-anchor">#</a> 布尔类型</h2> <p>true 和false</p> <h2 id="字符类型"><a href="#字符类型" class="header-anchor">#</a> 字符类型</h2> <h2 id="符合类型"><a href="#符合类型" class="header-anchor">#</a> 符合类型</h2> <h3 id="元组tuple"><a href="#元组tuple" class="header-anchor">#</a> 元组tuple</h3> <ul><li>长度是固定的</li> <li>支持解构</li></ul> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></div><ul><li>索引访问</li></ul> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></div><ul><li>()是一种特殊的类型(没有任何值), 该类型被称为单元类型, 如果表达式不返回任何其他值，就隐式地返回单元值, 有点类似void()默认返回undefined</li></ul> <h3 id="数组array"><a href="#数组array" class="header-anchor">#</a> 数组array</h3> <ul><li>长度是固定的</li> <li>每个元素必须拥有相同类型</li> <li>如果要长度不固定可以使用vector</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let a = [3:5]; 表示let a = [3, 3, 3, 3, 3]
</code></pre></div><h1 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h1> <p>与javascript类似</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let y = 6;
}
</code></pre></div><h2 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h2> <p>执行操作但不返回值</p> <h2 id="表达式"><a href="#表达式" class="header-anchor">#</a> 表达式</h2> <ul><li>计算并产生一个值</li> <li>表达式的结尾没有分号</li></ul> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></div><h1 id="控制流"><a href="#控制流" class="header-anchor">#</a> 控制流</h1> <h2 id="if表达式"><a href="#if表达式" class="header-anchor">#</a> if表达式</h2> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></div><h3 id="let中也可以使用if"><a href="#let中也可以使用if" class="header-anchor">#</a> let中也可以使用if</h3> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></div><h2 id="loop"><a href="#loop" class="header-anchor">#</a> loop</h2> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {}&quot;, count);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {}&quot;, remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {}&quot;, count);
}
</code></pre></div><h3 id="从循环返回"><a href="#从循环返回" class="header-anchor">#</a> 从循环返回</h3> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre></div><h2 id="while"><a href="#while" class="header-anchor">#</a> while</h2> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></div><h2 id="for"><a href="#for" class="header-anchor">#</a> for</h2> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></div><h1 id="所有权-ownership"><a href="#所有权-ownership" class="header-anchor">#</a> 所有权(ownership)</h1> <ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li> <li>值在任一时刻有且只有一个所有者。</li> <li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ul> <h2 id="变量作用域"><a href="#变量作用域" class="header-anchor">#</a> 变量作用域</h2> <div class="language- extra-class"><pre class="language-text"><code>    {                      // s 在这里无效, 它尚未声明
        let s = &quot;hello&quot;;   // 从此处起，s 开始有效

        // 使用 s
    }                      // 此作用域已结束，s 不再有效
</code></pre></div><h2 id="string类型"><a href="#string类型" class="header-anchor">#</a> String类型</h2> <p>管理被分配到堆上的数据</p> <div class="language- extra-class"><pre class="language-text"><code>  let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值

    println!(&quot;{}&quot;, s); // 将打印 `hello, world!`
</code></pre></div><h2 id="数据交互方式一-move"><a href="#数据交互方式一-move" class="header-anchor">#</a> 数据交互方式一: Move</h2> <p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p> <ul><li>必须在运行时向内存分配器请求内存。</li> <li>需要一个当我们处理完 String 时将内存返回给分配器的方法。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  let s1 = String::from(&quot;hello&quot;);
  let s2 = s1;
</code></pre></div><p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240425163816.png" alt="20240425163816"></p> <p>左侧为栈, 右侧为堆</p> <p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240425164109.png" alt="20240425164109"></p> <p>移动之后只有s2有效, s1会被释放</p> <p>Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。</p> <h3 id="长度和容量的区别是什么"><a href="#长度和容量的区别是什么" class="header-anchor">#</a> 长度和容量的区别是什么?</h3> <p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从分配器总共获取了多少字节的内容</p> <h2 id="数据交互方式二-clone"><a href="#数据交互方式二-clone" class="header-anchor">#</a> 数据交互方式二: Clone</h2> <div class="language- extra-class"><pre class="language-text"><code>   let s1 = String::from(&quot;hello&quot;);
   let s2 = s1.clone();

  println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
</code></pre></div><h2 id="只在栈上的数据-拷贝"><a href="#只在栈上的数据-拷贝" class="header-anchor">#</a> 只在栈上的数据: 拷贝</h2> <h3 id="copy-trait"><a href="#copy-trait" class="header-anchor">#</a> copy trait</h3> <p>如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用</p> <h3 id="实现了copy-trait的类型"><a href="#实现了copy-trait的类型" class="header-anchor">#</a> 实现了copy trait的类型</h3> <ul><li>所有整数类型，比如 u32。</li> <li>布尔类型，bool，它的值是 true 和 false。</li> <li>所有浮点数类型，比如 f64。</li> <li>字符类型，char。</li> <li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul> <h2 id="所有权与函数"><a href="#所有权与函数" class="header-anchor">#</a> 所有权与函数</h2> <p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
  let s = String::from(&quot;hello&quot;);  // s 进入作用域

  takes_ownership(s);             // s 的值移动到函数里 ...
                                  // ... 所以到这里不再有效

  let x = 5;                      // x 进入作用域

  makes_copy(x);                  // x 应该移动函数里，
                                  // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
  println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
  println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre></div><h2 id="返回值与作用域"><a href="#返回值与作用域" class="header-anchor">#</a> 返回值与作用域</h2> <p>返回值也可以转移所有权。</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
  let s1 = gives_ownership();         // gives_ownership 将返回值
                                      // 移给 s1

  let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

  let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                      // takes_and_gives_back 中,
                                      // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {           // gives_ownership 将返回值移动给
                                           // 调用它的函数

  let some_string = String::from(&quot;yours&quot;); // some_string 进入作用域

  some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

  a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></div><h1 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h1> <p>以一个对象的引用作为参数而不是获取值的所有权</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></div><p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240425165744.png" alt="20240425165744"></p> <h2 id="可变引用"><a href="#可变引用" class="header-anchor">#</a> 可变引用</h2> <p>正常引用是不可变的, 无法通过引用修改内容
如果要可变, 可以修改为mut</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></div><p>在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败：</p> <div class="language- extra-class"><pre class="language-text"><code>   let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
</code></pre></div><p>以下代码没问题</p> <div class="language- extra-class"><pre class="language-text"><code>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // 没问题
    let r2 = &amp;s; // 没问题
    println!(&quot;{} and {}&quot;, r1, r2);
    // 此位置之后 r1 和 r2 不再使用

    let r3 = &amp;mut s; // 没问题
    println!(&quot;{}&quot;, r3);
</code></pre></div><h2 id="悬垂引用-dangling-references"><a href="#悬垂引用-dangling-references" class="header-anchor">#</a> 悬垂引用（Dangling References）</h2> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s // 这里s离开作用域已经被释放掉了
}
</code></pre></div><h2 id="引用的规则"><a href="#引用的规则" class="header-anchor">#</a> 引用的规则</h2> <ul><li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li> <li>引用必须总是有效的。</li></ul> <h2 id="解引用"><a href="#解引用" class="header-anchor">#</a> 解引用 (*)</h2> <h1 id="切片-slice"><a href="#切片-slice" class="header-anchor">#</a> 切片(slice)</h1> <h2 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h2> <div class="language- extra-class"><pre class="language-text"><code>  let s = String::from(&quot;hello world&quot;);

  let hello = &amp;s[0..5];
  let world = &amp;s[6..11];
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` 接受 `String` 的切片，无论是部分还是全部
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` 也接受 `String` 的引用，
    // 这等同于 `String` 的全部切片
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` 接受字符串字面量的切片，无论是部分还是全部
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // 因为字符串字面值**就是**字符串 slice，
    // 这样写也可以，即不使用 slice 语法！
    let word = first_word(my_string_literal);
}
</code></pre></div><h2 id="其他类型"><a href="#其他类型" class="header-anchor">#</a> 其他类型</h2> <div class="language- extra-class"><pre class="language-text"><code>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
</code></pre></div><h1 id="struct"><a href="#struct" class="header-anchor">#</a> struct</h1> <p>或者 structure，是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合</p> <div class="language- extra-class"><pre class="language-text"><code>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 简洁写法类似Javascript
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn main() {
    // 两个.

    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
    // 发生了Move. 不能再使用user1了
}
</code></pre></div><h2 id="tuple-struct"><a href="#tuple-struct" class="header-anchor">#</a> tuple struct</h2> <div class="language- extra-class"><pre class="language-text"><code>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></div><h2 id="trait-功能"><a href="#trait-功能" class="header-anchor">#</a> trait 功能</h2> <p>在 {} 中加入 :? 指示符告诉 println! 我们想要使用叫做 Debug 的输出格式。Debug 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体，以便当我们调试代码时能看到它的值。</p> <div class="language- extra-class"><pre class="language-text"><code>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></div><p>{:#?} 格式化更明显</p> <h2 id="dbg"><a href="#dbg" class="header-anchor">#</a> dbg!</h2> <div class="language- extra-class"><pre class="language-text"><code>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></div><h2 id="方法语法"><a href="#方法语法" class="header-anchor">#</a> 方法语法</h2> <div class="language- extra-class"><pre class="language-text"><code>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // &amp;self 实际上是 self: &amp;Self 的缩写
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></div><h1 id="enums"><a href="#enums" class="header-anchor">#</a> enums</h1> <div class="language- extra-class"><pre class="language-text"><code>
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre></div><h2 id="option"><a href="#option" class="header-anchor">#</a> option</h2> <div class="language- extra-class"><pre class="language-text"><code>enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
</code></pre></div><h2 id="match"><a href="#match" class="header-anchor">#</a> match</h2> <div class="language- extra-class"><pre class="language-text"><code>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>#[derive(Debug)] // 这样可以立刻看到州的名称
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
</code></pre></div><h2 id="匹配options"><a href="#匹配options" class="header-anchor">#</a> 匹配Options</h2> <div class="language- extra-class"><pre class="language-text"><code>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
</code></pre></div><h2 id="other和"><a href="#other和" class="header-anchor">#</a> other和_</h2> <div class="language- extra-class"><pre class="language-text"><code>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
</code></pre></div><h2 id="if-let"><a href="#if-let" class="header-anchor">#</a> if let</h2> <div class="language- extra-class"><pre class="language-text"><code>let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
</code></pre></div><h1 id="项目结构"><a href="#项目结构" class="header-anchor">#</a> 项目结构</h1> <ul><li>包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li> <li>Crates ：一个模块的树形结构，它形成了库或二进制项目。</li> <li>模块（Modules）和 use： 允许你控制作用域和路径的私有性。</li> <li>路径（path）：一个命名例如结构体、函数或模块等项的方式</li></ul> <h2 id="包和crate"><a href="#包和crate" class="header-anchor">#</a> 包和crate</h2> <p>一个包中至多 只能 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的。</p> <h3 id="二进制"><a href="#二进制" class="header-anchor">#</a> 二进制</h3> <ul><li>单个 src/main.rs</li> <li>多个 src/bin/xxx.rs</li></ul> <h3 id="库"><a href="#库" class="header-anchor">#</a> 库</h3> <ul><li>src/lib.rs</li></ul> <h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <div class="language- extra-class"><pre class="language-text"><code>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre></div><h2 id="路径"><a href="#路径" class="header-anchor">#</a> 路径</h2> <div class="language- extra-class"><pre class="language-text"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
</code></pre></div><h3 id="绝对路径"><a href="#绝对路径" class="header-anchor">#</a> 绝对路径</h3> <p>从 crate 根部开始，以 crate 名或者字面量 crate 开头。</p> <div class="language- extra-class"><pre class="language-text"><code>crate::xxx
</code></pre></div><h3 id="相对路径"><a href="#相对路径" class="header-anchor">#</a> 相对路径</h3> <p>从当前模块开始，以 self、super 或当前模块的标识符开头。</p> <div class="language- extra-class"><pre class="language-text"><code>fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
</code></pre></div><h2 id="use"><a href="#use" class="header-anchor">#</a> use</h2> <div class="language- extra-class"><pre class="language-text"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre></div><h2 id="嵌套路径"><a href="#嵌套路径" class="header-anchor">#</a> 嵌套路径</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::cmp::Ordering;
use std::io;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>use std::{cmp::Ordering, io};
</code></pre></div><h1 id="vector"><a href="#vector" class="header-anchor">#</a> vector</h1> <div class="language- extra-class"><pre class="language-text"><code>let v: Vec&lt;i32&gt; = Vec::new();

let v2 = vec![1, 2, 3];
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
</code></pre></div><h2 id="读取"><a href="#读取" class="header-anchor">#</a> 读取</h2> <p>索引或者get</p> <div class="language- extra-class"><pre class="language-text"><code>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
</code></pre></div><h2 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h2> <div class="language- extra-class"><pre class="language-text"><code>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
</code></pre></div><h2 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h2> <div class="language- extra-class"><pre class="language-text"><code>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
</code></pre></div><h1 id="字符串-2"><a href="#字符串-2" class="header-anchor">#</a> 字符串</h1> <h2 id="新建"><a href="#新建" class="header-anchor">#</a> 新建</h2> <div class="language- extra-class"><pre class="language-text"><code>let mut s = String::new();
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>
let data = &quot;initial contents&quot;;

let s = data.to_string();

// 该方法也可直接用于字符串字面量：
let s = &quot;initial contents&quot;.to_string();
</code></pre></div><h2 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h2> <div class="language- extra-class"><pre class="language-text"><code>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用
</code></pre></div><h2 id="拼接"><a href="#拼接" class="header-anchor">#</a> 拼接</h2> <div class="language- extra-class"><pre class="language-text"><code>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
</code></pre></div><h2 id="内部表现"><a href="#内部表现" class="header-anchor">#</a> 内部表现</h2> <p>String 是一个 <code>Vec&lt;u8&gt;</code> 的封装</p> <h2 id="slice"><a href="#slice" class="header-anchor">#</a> slice</h2> <div class="language- extra-class"><pre class="language-text"><code>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
</code></pre></div><h2 id="遍历-2"><a href="#遍历-2" class="header-anchor">#</a> 遍历</h2> <div class="language- extra-class"><pre class="language-text"><code>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
</code></pre></div><h1 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h1> <div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
</code></pre></div><h2 id="所有权"><a href="#所有权" class="header-anchor">#</a> 所有权</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// 这里 field_name 和 field_value 不再有效，
// 尝试使用它们看看会出现什么编译错误！
</code></pre></div><h2 id="访问"><a href="#访问" class="header-anchor">#</a> 访问</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}

</code></pre></div><h2 id="插入"><a href="#插入" class="header-anchor">#</a> 插入</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
</code></pre></div><h2 id="更新-2"><a href="#更新-2" class="header-anchor">#</a> 更新</h2> <div class="language- extra-class"><pre class="language-text"><code>
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
</code></pre></div><h2 id="根据旧值更新"><a href="#根据旧值更新" class="header-anchor">#</a> 根据旧值更新</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    // 解引用
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
</code></pre></div><h1 id="painic"><a href="#painic" class="header-anchor">#</a> painic</h1> <p>有的时候代码出问题了，而你对此束手无策。对于这种情况，Rust 有 panic!宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug，而且开发者并不清楚该如何处理它。</p> <h2 id="result"><a href="#result" class="header-anchor">#</a> Result</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></div><h2 id="unwrap-和expect"><a href="#unwrap-和expect" class="header-anchor">#</a> unwrap 和expect</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}

</code></pre></div><h2 id="传播错误"><a href="#传播错误" class="header-anchor">#</a> 传播错误</h2> <div class="language- extra-class"><pre class="language-text"><code>
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
</code></pre></div><h2 id="传播简写"><a href="#传播简写" class="header-anchor">#</a> 传播简写 ?</h2> <div class="language- extra-class"><pre class="language-text"><code>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Rust 的错误处理功能旨在帮助你编写更健壮的代码。panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 Result 来告诉代码调用者他需要处理潜在的成功或失败。在适当的场景使用 panic! 和 Result 将会使你的代码在面对不可避免的错误时显得更加可靠。</p> <p>现在我们已经见识过了标准库中 Option 和 Result 泛型枚举的能力了，在下一章让我们来聊聊泛型是如何工作的，以及如何在你的代码中使用它们。</p> <h1 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h1> <h2 id="函数-2"><a href="#函数-2" class="header-anchor">#</a> 函数</h2> <div class="language- extra-class"><pre class="language-text"><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></div><h2 id="结构体"><a href="#结构体" class="header-anchor">#</a> 结构体</h2> <div class="language- extra-class"><pre class="language-text"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></div><h2 id="枚举-2"><a href="#枚举-2" class="header-anchor">#</a> 枚举</h2> <div class="language- extra-class"><pre class="language-text"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre></div><h2 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h2> <div class="language- extra-class"><pre class="language-text"><code>struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></div><h2 id="单态化"><a href="#单态化" class="header-anchor">#</a> 单态化</h2> <p>填充编译时具体的类型, 转化为特定代码</p> <h1 id="trait"><a href="#trait" class="header-anchor">#</a> trait</h1> <p>trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。
有点像其他语言的接口</p> <div class="language- extra-class"><pre class="language-text"><code>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre></div><h2 id="类型实现trait"><a href="#类型实现trait" class="header-anchor">#</a> 类型实现trait</h2> <div class="language- extra-class"><pre class="language-text"><code>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre></div><h2 id="默认实现"><a href="#默认实现" class="header-anchor">#</a> 默认实现</h2> <div class="language- extra-class"><pre class="language-text"><code>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
</code></pre></div><h2 id="trait作为参数"><a href="#trait作为参数" class="header-anchor">#</a> trait作为参数</h2> <div class="language- extra-class"><pre class="language-text"><code>pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre></div><h2 id="指定多个trait"><a href="#指定多个trait" class="header-anchor">#</a> + 指定多个trait</h2> <div class="language- extra-class"><pre class="language-text"><code>pub fn notify(item: impl Summary + Display) {
</code></pre></div><h2 id="where"><a href="#where" class="header-anchor">#</a> where</h2> <div class="language- extra-class"><pre class="language-text"><code>fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{

// 等价

 fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre></div><h2 id="return"><a href="#return" class="header-anchor">#</a> return</h2> <div class="language- extra-class"><pre class="language-text"><code>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre></div><h2 id="example"><a href="#example" class="header-anchor">#</a> example</h2> <div class="language- extra-class"><pre class="language-text"><code>n largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></div><h1 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h1> <p>Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p> <h2 id="借用检查器"><a href="#借用检查器" class="header-anchor">#</a> 借用检查器</h2> <div class="language- extra-class"><pre class="language-text"><code>{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre></div><p>这里将 r 的生命周期标记为 'a 并将 x 的生命周期标记为 'b。如你所见，内部的 'b 块要比外部的生命周期 'a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。</p> <h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="header-anchor">#</a> 生命周期标注语法</h2> <div class="language- extra-class"><pre class="language-text"><code>&amp;i32        // 引用
&amp;'a i32     // 带有显式生命周期的引用
&amp;'a mut i32 // 带有显式生命周期的可变引用
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></div><h1 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h1> <p>Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。</p> <div class="language- extra-class"><pre class="language-text"><code>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}

</code></pre></div><h2 id="lazy-avaluation"><a href="#lazy-avaluation" class="header-anchor">#</a> lazy avaluation</h2> <div class="language- extra-class"><pre class="language-text"><code>struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></div><h2 id="捕获环境"><a href="#捕获环境" class="header-anchor">#</a> 捕获环境</h2> <ul><li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li> <li>FnMut 获取可变的借用值所以可以改变其环境</li> <li>Fn 从其环境获取不可变的借用值</li></ul> <h2 id="move"><a href="#move" class="header-anchor">#</a> move</h2> <p>获取所有权</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

</code></pre></div><h1 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h1> <div class="language- extra-class"><pre class="language-text"><code>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
</code></pre></div><p>迭代器的实现</p> <div class="language- extra-class"><pre class="language-text"><code>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 此处省略了方法的默认实现
}
</code></pre></div><h2 id="map"><a href="#map" class="header-anchor">#</a> map</h2> <div class="language- extra-class"><pre class="language-text"><code>
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
</code></pre></div><h2 id="闭包获取环境"><a href="#闭包获取环境" class="header-anchor">#</a> 闭包获取环境</h2> <div class="language- extra-class"><pre class="language-text"><code>#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
</code></pre></div><h1 id="box"><a href="#box" class="header-anchor">#</a> Box<T></T></h1> <p>box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针</p> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
   let b = Box::new(5);
   println!(&quot;b = {}&quot;, b);
}

</code></pre></div><h1 id="解引用-2"><a href="#解引用-2" class="header-anchor">#</a> 解引用</h1> <div class="language- extra-class"><pre class="language-text"><code>fn main() {
   let x = 5;
   let y = &amp;x;

   assert_eq!(5, x);
   assert_eq!(5, *y);
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>*y 等价于 *(y.deref())
</code></pre></div><h2 id="解引用强制转换"><a href="#解引用强制转换" class="header-anchor">#</a> 解引用强制转换</h2> <p>Rust 在函数或方法传参上的一种便利。解引用强制转换只能工作在实现了 Deref trait 的类型上。解引用强制转换将一种类型（A）隐式转换为另外一种类型（B）的引用，因为 A 类型实现了 Deref trait，并且其关联类型是 B 类型。比如，解引用强制转换可以将 &amp;String 转换为 &amp;str，因为类型 String 实现了 Deref trait 并且其关联类型是 str</p> <p>当我们将特定类型的值的引用作为参数传递给函数或方法，但是被传递的值的引用与函数或方法中定义的参数类型不匹配时，会发生解引用强制转换。这时会有一系列的 deref 方法被调用，把我们提供的参数类型转换成函数或方法需要的参数类型。</p> <h2 id="解引用强制转换-2"><a href="#解引用强制转换-2" class="header-anchor">#</a> 解引用强制转换</h2> <ul><li>当 T: Deref&lt;Target=U&gt; ：从 &amp;T 到 &amp;U。</li> <li>当 T: DerefMut&lt;Target=U&gt; ：从 &amp;mut T 到 &amp;mut U。</li> <li>当 T: Deref&lt;Target=U&gt; ：从 &amp;mut T 到 &amp;U。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/matt-blog/pages/react-native/react-native bridge原理探究.html" class="prev">
        react-native bridge原理探究
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/matt-blog/assets/js/app.ffdfc81f.js" defer></script><script src="/matt-blog/assets/js/2.778bb4ad.js" defer></script><script src="/matt-blog/assets/js/1.f8bb34da.js" defer></script><script src="/matt-blog/assets/js/29.e94060ac.js" defer></script>
  </body>
</html>
