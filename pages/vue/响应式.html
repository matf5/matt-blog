<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue是如何实现响应式的 | matt的前端之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/matt-blog/cainiao.jpg">
    <meta name="description" content="matt的前端之路">
    
    <link rel="preload" href="/matt-blog/assets/css/0.styles.67df34d8.css" as="style"><link rel="preload" href="/matt-blog/assets/js/app.5d95d86b.js" as="script"><link rel="preload" href="/matt-blog/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/matt-blog/assets/js/1.f8bb34da.js" as="script"><link rel="preload" href="/matt-blog/assets/js/51.d1c6fe7e.js" as="script"><link rel="prefetch" href="/matt-blog/assets/js/10.fde088a2.js"><link rel="prefetch" href="/matt-blog/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/matt-blog/assets/js/12.27d4f152.js"><link rel="prefetch" href="/matt-blog/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/matt-blog/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/matt-blog/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/matt-blog/assets/js/16.85253907.js"><link rel="prefetch" href="/matt-blog/assets/js/17.c2838453.js"><link rel="prefetch" href="/matt-blog/assets/js/18.3256f17f.js"><link rel="prefetch" href="/matt-blog/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/matt-blog/assets/js/20.0d880388.js"><link rel="prefetch" href="/matt-blog/assets/js/21.33b300c9.js"><link rel="prefetch" href="/matt-blog/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/matt-blog/assets/js/23.4db98f57.js"><link rel="prefetch" href="/matt-blog/assets/js/24.d02ac95a.js"><link rel="prefetch" href="/matt-blog/assets/js/25.2773990a.js"><link rel="prefetch" href="/matt-blog/assets/js/26.3f9a83a0.js"><link rel="prefetch" href="/matt-blog/assets/js/27.76956e48.js"><link rel="prefetch" href="/matt-blog/assets/js/28.a1a2f2a8.js"><link rel="prefetch" href="/matt-blog/assets/js/29.6e123920.js"><link rel="prefetch" href="/matt-blog/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/matt-blog/assets/js/30.caa352c9.js"><link rel="prefetch" href="/matt-blog/assets/js/31.1d76566f.js"><link rel="prefetch" href="/matt-blog/assets/js/32.c4bb4de8.js"><link rel="prefetch" href="/matt-blog/assets/js/33.39437f0e.js"><link rel="prefetch" href="/matt-blog/assets/js/34.aeff76a3.js"><link rel="prefetch" href="/matt-blog/assets/js/35.eff53b64.js"><link rel="prefetch" href="/matt-blog/assets/js/36.82f9ebe4.js"><link rel="prefetch" href="/matt-blog/assets/js/37.159089ca.js"><link rel="prefetch" href="/matt-blog/assets/js/38.7b02d561.js"><link rel="prefetch" href="/matt-blog/assets/js/39.aad63f87.js"><link rel="prefetch" href="/matt-blog/assets/js/4.45665f8a.js"><link rel="prefetch" href="/matt-blog/assets/js/40.55886bac.js"><link rel="prefetch" href="/matt-blog/assets/js/41.2a8e9d15.js"><link rel="prefetch" href="/matt-blog/assets/js/42.a714b810.js"><link rel="prefetch" href="/matt-blog/assets/js/43.10b4130b.js"><link rel="prefetch" href="/matt-blog/assets/js/44.55b42df6.js"><link rel="prefetch" href="/matt-blog/assets/js/45.96e83476.js"><link rel="prefetch" href="/matt-blog/assets/js/46.78bc5c37.js"><link rel="prefetch" href="/matt-blog/assets/js/47.1fcb8069.js"><link rel="prefetch" href="/matt-blog/assets/js/48.eccb93b8.js"><link rel="prefetch" href="/matt-blog/assets/js/49.2974f0ce.js"><link rel="prefetch" href="/matt-blog/assets/js/5.7098d77a.js"><link rel="prefetch" href="/matt-blog/assets/js/50.3dee0a22.js"><link rel="prefetch" href="/matt-blog/assets/js/52.0e6ae343.js"><link rel="prefetch" href="/matt-blog/assets/js/53.093f95eb.js"><link rel="prefetch" href="/matt-blog/assets/js/54.7b48c16a.js"><link rel="prefetch" href="/matt-blog/assets/js/55.783c32bb.js"><link rel="prefetch" href="/matt-blog/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/matt-blog/assets/js/7.6a854e57.js"><link rel="prefetch" href="/matt-blog/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/matt-blog/assets/css/0.styles.67df34d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/matt-blog/" class="home-link router-link-active"><img src="/matt-blog/cainiao.jpg" alt="matt的前端之路" class="logo"> <span class="site-name can-hide">matt的前端之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hybrid</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mini-program</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>performance</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目经验剖析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>qwik</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-native</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>rust</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/matt-blog/pages/vue/tsx-in-vue.html" class="sidebar-link">tsx</a></li><li><a href="/matt-blog/pages/vue/响应式.html" class="active sidebar-link">响应式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/响应式.html#watcher" class="sidebar-link">watcher</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/响应式.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/响应式.html#不足" class="sidebar-link">不足</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/响应式.html#nexttick的执行时机" class="sidebar-link">nextTick的执行时机</a></li></ul></li><li><a href="/matt-blog/pages/vue/框架分析.html" class="sidebar-link">框架分析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>xiaochengxu</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue是如何实现响应式的"><a href="#vue是如何实现响应式的" class="header-anchor">#</a> vue是如何实现响应式的</h1> <p>使用双向绑定的模式
vue2是通过defineProperty劫持对象的set和get属性
在get数据的时候, 收集订阅者, 触发watcher的依赖收集, set数据时会发布更新,  通知watcher
<img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240424172405.png" alt="20240424172405"></p> <p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240424172251.png" alt="20240424172251"></p> <h2 id="watcher"><a href="#watcher" class="header-anchor">#</a> watcher</h2> <ol><li>观察模版中的水</li> <li>watch选项中的数据</li></ol> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Vue 的响应式原理的核心就是观察这些数据的变化，当这些数据发生变化以后，能通知到对应的观察者以实现相关的逻辑。整个响应式原理最核心的实现就是 Dep 类，这个类实际上是连接数据与观察者的桥梁。</p> <p>在 Vue 初始化阶段，会对配置对象中定义的不同属性做相关的处理，对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性，同时它们内部会持有一个 Dep 实例对象，当我们访问这些数据的时候，就会触发 dep 的 depend 方法来收集依赖，这些依赖是当前正在计算的 Watcher，当前在计算的依赖也就是 Dep.target，作为 Subscriber 订阅者用于订阅这些数据的变化。当修改数据的时候，会触发 dep 的 notify 方法通知这些订阅者执行 update 的逻辑。</p> <p>对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 evaluate 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。</p> <p>对于 watch 而言，会创建一个 user watcher，可以理解为用户的 watcher，也就是用户自定义的一些 watch，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，我们创建的这个 watcher 去观察某个数据或计算属性，让他们发生变化就会通知这个 Dep 然后调用这个 Dep 去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。</p> <p>Vue 的渲染都是基于这个响应式系统的。在 Vue 的创建过程中，对于每个组件而言，它都会执行组件的 $mount 方法，$mount 执行过程中内部会创建唯一的 render watcher，该 render watcher 会在 render 也就是创建 VNode 过程中会访问到定义的 data、props 或者 computed 等等。render watcher 相当于订阅者，订阅了这些定义的数据的变化，一旦它们发生变化以后，就会触发例如 setter 里的 notify 或者 computed watcher 中的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程中最终会调用 updateComponent 的方法，该方法会重新进行视图渲染。</p> <h2 id="不足"><a href="#不足" class="header-anchor">#</a> 不足</h2> <ol><li>无法监控对象的增山</li> <li>数组的修改</li></ol> <h2 id="nexttick的执行时机"><a href="#nexttick的执行时机" class="header-anchor">#</a> nextTick的执行时机</h2> <p>当你在Vue中修改响应式数据时，DOM并不会立即同步更新。相反，Vue会将这些更新操作缓冲到一个队列中，并在下一个“事件循环tick”中异步地执行它们。这样做是为了避免不必要的DOM操作和重复渲染，从而提高性能。</p> <h3 id="ui渲染与事件循环"><a href="#ui渲染与事件循环" class="header-anchor">#</a> UI渲染与事件循环</h3> <p><strong>UI渲染不完全等同于一个宏任务</strong>，但它是事件循环（Event Loop）中的一个独立且关键的环节。浏览器会根据自身的刷新率（通常是60Hz，即约16.6ms一次）来决定何时进行UI渲染。</p> <h4 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="header-anchor">#</a> 浏览器事件循环机制</h4> <p>JavaScript是单线程的，为了处理异步操作，引入了事件循环机制。其执行顺序大致如下：</p> <ol><li><strong>执行同步代码</strong>：首先执行调用栈（Call Stack）中的所有同步代码。</li> <li><strong>执行微任务</strong>：当调用栈为空后，检查微任务队列（Microtask Queue），并执行其中的所有微任务，直到队列清空。如果在执行微任务的过程中又产生了新的微任务，它们也会被添加到队列末尾并在当前轮次中执行完毕。</li> <li><strong>UI渲染（可选）</strong>：微任务队列清空后，浏览器会进行一次UI渲染（Repaint/Reflow）。这个步骤不是每次事件循环都必然发生，而是由浏览器根据性能和时机来决定。</li> <li><strong>执行宏任务</strong>：从宏任务队列（Macrotask Queue）中取出一个宏任务，放入调用栈中执行。</li> <li><strong>重复循环</strong>：宏任务执行完毕后，再次回到第2步，开始新一轮的循环（tick）。</li></ol> <p><strong>简单总结：一次事件循环 = 执行一个宏任务 -&gt; 执行所有微任务 -&gt; （可能）UI渲染</strong></p> <ul><li><strong>宏任务 (Macrotasks)</strong>: <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O 操作, UI 交互事件, <code>script</code> 标签中的代码本身。</li> <li><strong>微任务 (Microtasks)</strong>: <code>Promise.then/catch/finally</code>, <code>MutationObserver</code>, <code>process.nextTick</code> (Node.js)。</li></ul> <p><code>nextTick</code> 正是利用了这个机制，将回调函数推入微任务队列（或在不支持的环境下降级为宏任务），确保它在DOM更新（属于UI渲染的一部分）之后、但在下一个宏任务开始之前执行。</p> <p><strong>执行时机总结:</strong></p> <ol><li><strong>数据变更后</strong>: 当你修改了 <code>data</code> 中的属性。</li> <li><strong>DOM更新前</strong>: Vue将DOM更新任务推入一个异步队列。</li> <li><strong><code>nextTick</code>回调入队</strong>: 调用 <code>nextTick(callback)</code> 时，这个 <code>callback</code> 也会被推入同一个异步队列，但它会排在DOM更新任务之后。</li> <li><strong>事件循环Tick</strong>: 在当前同步代码执行完毕后，事件循环会开始处理异步队列。</li> <li><strong>DOM更新</strong>: Vue执行队列中的DOM更新操作。</li> <li><strong><code>nextTick</code>回调执行</strong>: DOM更新完成后，执行 <code>nextTick</code> 的回调函数。</li></ol> <p><strong>内部实现:</strong></p> <p>Vue会优先使用微任务（microtask）来实现 <code>nextTick</code>，比如 <code>Promise.then</code> 或 <code>MutationObserver</code>。如果环境不支持，它会降级为宏任务（macrotask），比如 <code>setImmediate</code> 或 <code>setTimeout(fn, 0)</code>。优先使用微任务是因为它们会在当前宏任务结束后的UI渲染之前执行，能更快地响应。</p> <h1 id="vue3响应式"><a href="#vue3响应式" class="header-anchor">#</a> vue3响应式</h1> <p><img src="https://raw.githubusercontent.com/matf5/fileCache/master/20240424172614.png" alt="20240424172614"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/matt-blog/pages/vue/tsx-in-vue.html" class="prev">
        tsx
      </a></span> <span class="next"><a href="/matt-blog/pages/vue/框架分析.html">
        框架分析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/matt-blog/assets/js/app.5d95d86b.js" defer></script><script src="/matt-blog/assets/js/2.778bb4ad.js" defer></script><script src="/matt-blog/assets/js/1.f8bb34da.js" defer></script><script src="/matt-blog/assets/js/51.d1c6fe7e.js" defer></script>
  </body>
</html>
