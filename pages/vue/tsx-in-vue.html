<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 中使用 TSX 的深度剖析 | matt的前端之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/matt-blog/cainiao.jpg">
    <meta name="description" content="matt的前端之路">
    
    <link rel="preload" href="/matt-blog/assets/css/0.styles.67df34d8.css" as="style"><link rel="preload" href="/matt-blog/assets/js/app.7a7664f4.js" as="script"><link rel="preload" href="/matt-blog/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/matt-blog/assets/js/1.f8bb34da.js" as="script"><link rel="preload" href="/matt-blog/assets/js/47.c3c337ce.js" as="script"><link rel="prefetch" href="/matt-blog/assets/js/10.fde088a2.js"><link rel="prefetch" href="/matt-blog/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/matt-blog/assets/js/12.27d4f152.js"><link rel="prefetch" href="/matt-blog/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/matt-blog/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/matt-blog/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/matt-blog/assets/js/16.85253907.js"><link rel="prefetch" href="/matt-blog/assets/js/17.c2838453.js"><link rel="prefetch" href="/matt-blog/assets/js/18.3256f17f.js"><link rel="prefetch" href="/matt-blog/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/matt-blog/assets/js/20.0d880388.js"><link rel="prefetch" href="/matt-blog/assets/js/21.33b300c9.js"><link rel="prefetch" href="/matt-blog/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/matt-blog/assets/js/23.63ac009e.js"><link rel="prefetch" href="/matt-blog/assets/js/24.c4e74665.js"><link rel="prefetch" href="/matt-blog/assets/js/25.2773990a.js"><link rel="prefetch" href="/matt-blog/assets/js/26.3f9a83a0.js"><link rel="prefetch" href="/matt-blog/assets/js/27.52956252.js"><link rel="prefetch" href="/matt-blog/assets/js/28.133d2005.js"><link rel="prefetch" href="/matt-blog/assets/js/29.f6e670df.js"><link rel="prefetch" href="/matt-blog/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/matt-blog/assets/js/30.efd5b57a.js"><link rel="prefetch" href="/matt-blog/assets/js/31.decf9bc8.js"><link rel="prefetch" href="/matt-blog/assets/js/32.0d5a73e9.js"><link rel="prefetch" href="/matt-blog/assets/js/33.2c5c2242.js"><link rel="prefetch" href="/matt-blog/assets/js/34.d99cbb4d.js"><link rel="prefetch" href="/matt-blog/assets/js/35.91f7c444.js"><link rel="prefetch" href="/matt-blog/assets/js/36.dc5b6fb6.js"><link rel="prefetch" href="/matt-blog/assets/js/37.db2f2de1.js"><link rel="prefetch" href="/matt-blog/assets/js/38.54ca14b4.js"><link rel="prefetch" href="/matt-blog/assets/js/39.98ee8e5e.js"><link rel="prefetch" href="/matt-blog/assets/js/4.45665f8a.js"><link rel="prefetch" href="/matt-blog/assets/js/40.2194fa50.js"><link rel="prefetch" href="/matt-blog/assets/js/41.71587332.js"><link rel="prefetch" href="/matt-blog/assets/js/42.6c76a53f.js"><link rel="prefetch" href="/matt-blog/assets/js/43.8513fc47.js"><link rel="prefetch" href="/matt-blog/assets/js/44.2a12321b.js"><link rel="prefetch" href="/matt-blog/assets/js/45.30b47881.js"><link rel="prefetch" href="/matt-blog/assets/js/46.96cfa6b0.js"><link rel="prefetch" href="/matt-blog/assets/js/48.a8674bc1.js"><link rel="prefetch" href="/matt-blog/assets/js/49.4e0abe6d.js"><link rel="prefetch" href="/matt-blog/assets/js/5.7098d77a.js"><link rel="prefetch" href="/matt-blog/assets/js/50.7b77f845.js"><link rel="prefetch" href="/matt-blog/assets/js/51.5b7788d8.js"><link rel="prefetch" href="/matt-blog/assets/js/52.3ec62400.js"><link rel="prefetch" href="/matt-blog/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/matt-blog/assets/js/7.6a854e57.js"><link rel="prefetch" href="/matt-blog/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/matt-blog/assets/css/0.styles.67df34d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/matt-blog/" class="home-link router-link-active"><img src="/matt-blog/cainiao.jpg" alt="matt的前端之路" class="logo"> <span class="site-name can-hide">matt的前端之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hybrid</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mini-program</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>performance</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>qwik</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-native</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>rust</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/matt-blog/pages/vue/tsx-in-vue.html" aria-current="page" class="active sidebar-link">tsx</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/tsx-in-vue.html#_1-vue-中使用-tsx-的优缺点" class="sidebar-link">1. Vue 中使用 TSX 的优缺点</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/vue/tsx-in-vue.html#_2-vue-2-vs-vue-3-tsx-支持的演进" class="sidebar-link">2. Vue 2 vs Vue 3：TSX 支持的演进</a></li></ul></li><li><a href="/matt-blog/pages/vue/响应式.html" class="sidebar-link">响应式</a></li><li><a href="/matt-blog/pages/vue/框架分析.html" class="sidebar-link">框架分析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>xiaochengxu</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-中使用-tsx-的深度剖析"><a href="#vue-中使用-tsx-的深度剖析" class="header-anchor">#</a> Vue 中使用 TSX 的深度剖析</h1> <p>在 Vue 的生态中，是否选择使用 TSX (或 JSX) 而不是传统的模板语法（SFC, Single File Component），是一个常见的技术探讨话题。这并非一个简单的“好”与“坏”的判断，而是一个基于具体场景的<strong>权衡与取舍</strong>。</p> <p>本文将从优缺点、Vue 2 与 Vue 3 的差异，以及常见的面试问题三个方面，深入剖析在 Vue 中使用 TSX 的方方面面。</p> <hr> <h2 id="_1-vue-中使用-tsx-的优缺点"><a href="#_1-vue-中使用-tsx-的优缺点" class="header-anchor">#</a> 1. Vue 中使用 TSX 的优缺点</h2> <h3 id="优点-advantages"><a href="#优点-advantages" class="header-anchor">#</a> 优点 (Advantages)</h3> <h4 id="a-终极的灵活性-ultimate-flexibility"><a href="#a-终极的灵活性-ultimate-flexibility" class="header-anchor">#</a> a. 终极的灵活性 (Ultimate Flexibility)</h4> <ul><li><strong>完整的编程能力</strong>: 你可以直接在渲染逻辑中使用 JavaScript/TypeScript 的所有原生语法，如 <code>if/else</code>、<code>switch</code>、<code>map</code>、<code>reduce</code> 等，而无需学习 <code>v-if</code>, <code>v-for</code> 等特定的模板指令。这在处理非常复杂的动态渲染逻辑时尤其强大。</li> <li><strong>动态组件与高阶组件 (HOCs)</strong>: TSX 使得创建高阶组件或根据条件动态渲染不同类型的组件变得非常直接和简单，其逻辑表达比使用 <code>&lt;component :is=&quot;...&quot;&gt;</code> 更加清晰。</li></ul> <h4 id="b-与类型系统的深度集成-deep-type-system-integration"><a href="#b-与类型系统的深度集成-deep-type-system-integration" class="header-anchor">#</a> b. 与类型系统的深度集成 (Deep Type System Integration)</h4> <ul><li><strong>核心优势</strong>: TSX 本质上就是 TypeScript。这意味着你的 props、事件、插槽都可以获得无缝且强大的类型推导和编译时检查。</li> <li><strong>类型精确性</strong>: 虽然现代的 Vue 工具链（如 Volar）已经极大地改善了模板的类型支持，但在处理复杂的泛型组件或作用域插槽的 props 时，模板的类型推导有时仍可能遇到瓶颈。TSX 从语言层面根本性地解决了这个问题。</li></ul> <h4 id="c-更易于重构和抽象-easier-to-refactor-abstract"><a href="#c-更易于重构和抽象-easier-to-refactor-abstract" class="header-anchor">#</a> c. 更易于重构和抽象 (Easier to Refactor &amp; Abstract)</h4> <ul><li><strong>遵循标准</strong>: 组件内的逻辑抽取和重构完全遵循标准的 TS/JS 语法，能够得到 IDE 最完善的支持。你可以轻松地将一段复杂的 JSX 结构抽离成一个独立的函数进行复用，而模板的复用则更多地依赖于组件或插槽。</li></ul> <h4 id="d-对-react-开发者友好-friendly-to-react-developers"><a href="#d-对-react-开发者友好-friendly-to-react-developers" class="header-anchor">#</a> d. 对 React 开发者友好 (Friendly to React Developers)</h4> <ul><li><strong>心智模型一致</strong>: 对于有 React 开发背景的开发者而言，TSX 的学习成本几乎为零，心智模型可以平滑迁移。</li></ul> <h3 id="缺点-disadvantages"><a href="#缺点-disadvantages" class="header-anchor">#</a> 缺点 (Disadvantages)</h3> <h4 id="a-失去-vue-特有的语法糖-loss-of-vue-specific-syntax-sugar"><a href="#a-失去-vue-特有的语法糖-loss-of-vue-specific-syntax-sugar" class="header-anchor">#</a> a. 失去 Vue 特有的语法糖 (Loss of Vue-specific Syntax Sugar)</h4> <ul><li><strong>指令缺失</strong>: <code>v-model</code>, <code>v-show</code>, <code>v-if</code>, <code>v-for</code> 等这些在模板中非常简洁高效的指令都无法直接使用，需要用原生 JSX 的方式去“模拟”。
<ul><li><code>v-if</code> -&gt; ```tsx
{condition &amp;&amp; <div></div>}</li></ul> <div class="language- extra-class"><pre class="language-text"><code>-   `v-model` -&gt; 手动传递 `value` 和 `onChange` 事件
</code></pre></div></li> <li><strong>修饰符缺失</strong>: 如 <code>.prevent</code>, <code>.stop</code>, <code>.lazy</code> 这类便捷的事件和 <code>v-model</code> 修饰符也无法使用，需要开发者手动实现其逻辑。</li></ul> <h4 id="b-代码更啰嗦-more-verbose"><a href="#b-代码更啰嗦-more-verbose" class="header-anchor">#</a> b. 代码更啰嗦 (More Verbose)</h4> <ul><li>对于简单的场景，JSX 往往比模板需要编写更多的代码。例如，一个简单的 <code>v-for</code> 循环，在模板中一行就能解决，而用 JSX 则需要写成 ```tsx
items.map(item =&gt; <div>{item.name}</div>)<div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></li></ul> <h4 id="c-scoped-css-的割裂感-scoped-css-disconnection"><a href="#c-scoped-css-的割裂感-scoped-css-disconnection" class="header-anchor">#</a> c. Scoped CSS 的割裂感 (Scoped CSS Disconnection)</h4> <ul><li>在 SFC (<code>.vue</code> 文件) 中，<code>&lt;style scoped&gt;</code> 提供了一种非常优雅且隔离良好的组件级样式方案。但在 <code>.tsx</code> 文件中，你无法使用这个特性，必须转而依赖 CSS Modules, CSS-in-JS 等外部方案，这无疑增加了工程的复杂性。</li></ul> <h4 id="d-心智模型转换-mental-model-shift"><a href="#d-心智模型转换-mental-model-shift" class="header-anchor">#</a> d. 心智模型转换 (Mental Model Shift)</h4> <ul><li>Vue 的设计哲学是“HTML 优先”，它对 HTML 的扩展是自然且直观的。而 JSX 的哲学是“JavaScript 优先”，它将 HTML 视作 JavaScript 的一部分。对于长期使用 Vue 模板的开发者来说，这需要一个心智模型的转变。</li></ul> <hr> <h2 id="_2-vue-2-vs-vue-3-tsx-支持的演进"><a href="#_2-vue-2-vs-vue-3-tsx-支持的演进" class="header-anchor">#</a> 2. Vue 2 vs Vue 3：TSX 支持的演进</h2> <p>Vue 2 和 Vue 3 对 TSX 的支持存在<strong>根本性</strong>的差异，这主要源于它们底层数据响应式系统和组件 API 的不同（Options API vs Composition API）。</p> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">Vue 2 + TSX</th> <th style="text-align:left;">Vue 3 + TSX</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>核心原理</strong></td> <td style="text-align:left;">基于 <code>@vue/babel-preset-jsx</code> 实现。与 Options API 深度绑定，强依赖 <code>this</code> 上下文来访问数据和方法。</td> <td style="text-align:left;">作为<strong>一等公民</strong>进行支持。与 Composition API 完美结合，逻辑在 <code>setup</code> 函数中组织，完全不依赖 <code>this</code>。</td></tr> <tr><td style="text-align:left;"><strong>状态和逻辑</strong></td> <td style="text-align:left;">所有数据 (<code>data</code>) 和方法 (<code>methods</code>) 都必须从 <code>this</code> 上下文读取，如 <code>this.message</code>、<code>this.handleClick</code>。</td> <td style="text-align:left;">状态通过 <code>ref</code>、<code>reactive</code> 创建，逻辑在 <code>setup</code> 中定义。代码组织更聚合，更易于复用。</td></tr> <tr><td style="text-align:left;"><strong><code>v-model</code> 实现</strong></td> <td style="text-align:left;"><strong>相对复杂</strong>。需要手动处理 <code>value</code> prop 和 <code>input</code> 事件，或依赖 Babel 插件进行转换。代码通常类似：```tsx</td> <td style="text-align:left;"></td></tr></tbody></table>  =&gt; this.value = e.target.value} /&gt;
<p><code>| **简单直观**。遵循 `modelValue` prop 和 `onUpdate:modelValue` 事件的约定即可。Vue 3 的 JSX 转换也内置了对 `v-model` 的语法糖支持。 | | **插槽 (Slots)** | 通过 `this.$slots` 访问普通插槽，`this.$scopedSlots` 访问作用域插槽。API 分裂，容易混淆。 | 统一通过 `setup` 的 `context.slots` 或 `useSlots()` API 访问，API 一致且类型支持更好。在 JSX 中调用就像一个函数：</code>tsx
slots.default()
<code>或</code>tsx
slots.header({ scopeValue })</p> <div class="language-。 | extra-class"><pre class="language-text"><code>| **事件处理** | 事件需要写在 `on` 对象中，如 `on={{ click: this.handleClick }}`。原生DOM事件则需要 `nativeOn`。 | **与原生 HTML/React 一致**。事件直接以 `on` 前缀作为 prop 写入，如 ```tsx
&lt;button onClick={handleClick}&gt;&lt;/button&gt;
```。 |
| **类型支持** | 相对薄弱，尤其在 Props、事件和插槽的类型推导上，往往需要开发者编写大量手动的类型定义和断言。 | **非常完善**。得益于 Composition API 和更强大的 TS 集成，Props、Emits、Slots 都能获得开箱即用的、精确的类型推断。 |

**小结**：Vue 3 的 TSX 开发体验**远胜于** Vue 2。它更现代化、类型支持更完善、心智模型也与 Composition API 高度统一，真正让 TSX 成为了一个在 Vue 生态中实用且强大的选项。

---

## 3. 面试场景剖析

在面试中，面试官通过此问题通常想考察你对技术的**深度理解**、**选型决策能力**以及**实际应用经验**。

#### 问题一：“为什么你的项目中要引入 TSX？是基于什么考虑？”

-   **解题思路**: **切忌泛泛而谈“因为灵活”**。必须结合具体的项目场景，展现你的决策依据。
-   **优秀回答**：“在我们的项目中，大部分组件仍然使用 Vue 的单文件组件（SFC），因为它开发效率高且 `scoped CSS` 非常方便。但我们在一些特定场景下引入了 TSX，最典型的是**一个动态表单/属性配置面板的组件**。这个组件需要根据传入的 Schema（一份 JSON 配置），动态地渲染出完全不同的表单项组合（输入框、下拉选择、颜色选择器等）。这种高度动态化的渲染逻辑，如果用 `v-if/v-else-if` 会导致模板非常冗长且难以维护。而使用 TSX，我们可以利用 `map` 和 `switch` 等原生 JS 语法，以一种更编程化、更清晰的方式来构建视图。同时，TSX 提供的端到端类型安全也保证了这种复杂组件的健壮性。”

#### 问题二：“你在 TSX 里是怎么实现组件的双向绑定（类似 `v-model`）的？”

-   **解题思路**: 考察你是否真的有实践经验。能清晰地说出 Vue 3 的约定是加分项。
-   **优秀回答**：“在 Vue 3 的 TSX 中，我们遵循官方的 `modelValue` 和 `onUpdate:modelValue` 事件约定来实现双向绑定。父组件通过 `modelValue` prop 将值传递给子组件，并监听 `onUpdate:modelValue` 事件来接收值的更新。在子组件内部，我们接收 `modelValue` prop 来显示值，当值需要改变时，通过 `emit('update:modelValue', newValue)` 来通知父组件。这套机制保证了单向数据流的清晰，并且可以得到完整的 TypeScript 类型支持。”

#### 问题三：“既然 TSX 这么灵活，为什么不把项目全部用 TSX 来写呢？”

-   **解题思路**: 考察你对技术选型的权衡能力（Trade-offs），展现你作为工程师的理性和成熟度。
-   **优秀回答**：“这是一个很好的问题。我们选择混合使用模板和 TSX，而不是全盘 TSX，主要基于以下几点权衡：
    1.  **开发效率与简洁性**: 对于大量结构固定、逻辑简单的纯展示组件，Vue 模板的语法更简洁，开发效率更高。
    2.  **样式方案**: 我们团队非常依赖 `scoped CSS` 来保证样式的隔离性，这是 TSX 文件不具备的能力。引入 CSS-in-JS 等方案会增加额外的工程复杂度和团队学习成本。
    3.  **生态与团队习惯**: Vue 的生态系统（如各种 UI 库）仍然是以模板为中心的。保持主流方案可以降低维护成本，也更符合团队大多数成员的开发习惯。
    我们的技术选型原则是：**用最适合的工具解决最适合的问题，而不是为了用某个技术而用它**。”
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/matt-blog/pages/rust/tools-and-project.html" class="prev">
        工具与项目管理
      </a></span> <span class="next"><a href="/matt-blog/pages/vue/响应式.html">
        响应式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/matt-blog/assets/js/app.7a7664f4.js" defer></script><script src="/matt-blog/assets/js/2.778bb4ad.js" defer></script><script src="/matt-blog/assets/js/1.f8bb34da.js" defer></script><script src="/matt-blog/assets/js/47.c3c337ce.js" defer></script>
  </body>
</html>
