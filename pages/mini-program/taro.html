<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Taro 框架深度解析 | matt的前端之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/matt-blog/cainiao.jpg">
    <meta name="description" content="matt的前端之路">
    
    <link rel="preload" href="/matt-blog/assets/css/0.styles.67df34d8.css" as="style"><link rel="preload" href="/matt-blog/assets/js/app.71e86090.js" as="script"><link rel="preload" href="/matt-blog/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/matt-blog/assets/js/1.f8bb34da.js" as="script"><link rel="preload" href="/matt-blog/assets/js/24.d02ac95a.js" as="script"><link rel="prefetch" href="/matt-blog/assets/js/10.fde088a2.js"><link rel="prefetch" href="/matt-blog/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/matt-blog/assets/js/12.27d4f152.js"><link rel="prefetch" href="/matt-blog/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/matt-blog/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/matt-blog/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/matt-blog/assets/js/16.85253907.js"><link rel="prefetch" href="/matt-blog/assets/js/17.c2838453.js"><link rel="prefetch" href="/matt-blog/assets/js/18.3256f17f.js"><link rel="prefetch" href="/matt-blog/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/matt-blog/assets/js/20.0d880388.js"><link rel="prefetch" href="/matt-blog/assets/js/21.33b300c9.js"><link rel="prefetch" href="/matt-blog/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/matt-blog/assets/js/23.4db98f57.js"><link rel="prefetch" href="/matt-blog/assets/js/25.2773990a.js"><link rel="prefetch" href="/matt-blog/assets/js/26.3f9a83a0.js"><link rel="prefetch" href="/matt-blog/assets/js/27.76956e48.js"><link rel="prefetch" href="/matt-blog/assets/js/28.d91bf143.js"><link rel="prefetch" href="/matt-blog/assets/js/29.a466f468.js"><link rel="prefetch" href="/matt-blog/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/matt-blog/assets/js/30.22bee9f6.js"><link rel="prefetch" href="/matt-blog/assets/js/31.1d76566f.js"><link rel="prefetch" href="/matt-blog/assets/js/32.c4bb4de8.js"><link rel="prefetch" href="/matt-blog/assets/js/33.519c9cbd.js"><link rel="prefetch" href="/matt-blog/assets/js/34.88ebc733.js"><link rel="prefetch" href="/matt-blog/assets/js/35.eff53b64.js"><link rel="prefetch" href="/matt-blog/assets/js/36.82f9ebe4.js"><link rel="prefetch" href="/matt-blog/assets/js/37.159089ca.js"><link rel="prefetch" href="/matt-blog/assets/js/38.ed6658c8.js"><link rel="prefetch" href="/matt-blog/assets/js/39.aad63f87.js"><link rel="prefetch" href="/matt-blog/assets/js/4.45665f8a.js"><link rel="prefetch" href="/matt-blog/assets/js/40.039f9789.js"><link rel="prefetch" href="/matt-blog/assets/js/41.2a8e9d15.js"><link rel="prefetch" href="/matt-blog/assets/js/42.a714b810.js"><link rel="prefetch" href="/matt-blog/assets/js/43.10b4130b.js"><link rel="prefetch" href="/matt-blog/assets/js/44.59650f89.js"><link rel="prefetch" href="/matt-blog/assets/js/45.96e83476.js"><link rel="prefetch" href="/matt-blog/assets/js/46.53181746.js"><link rel="prefetch" href="/matt-blog/assets/js/47.fdee3dd3.js"><link rel="prefetch" href="/matt-blog/assets/js/48.5fb19d7f.js"><link rel="prefetch" href="/matt-blog/assets/js/49.5e450d62.js"><link rel="prefetch" href="/matt-blog/assets/js/5.7098d77a.js"><link rel="prefetch" href="/matt-blog/assets/js/50.3dee0a22.js"><link rel="prefetch" href="/matt-blog/assets/js/51.7403a464.js"><link rel="prefetch" href="/matt-blog/assets/js/52.39fbb785.js"><link rel="prefetch" href="/matt-blog/assets/js/53.1750e5fe.js"><link rel="prefetch" href="/matt-blog/assets/js/54.6154a915.js"><link rel="prefetch" href="/matt-blog/assets/js/55.67d3b7c1.js"><link rel="prefetch" href="/matt-blog/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/matt-blog/assets/js/7.6a854e57.js"><link rel="prefetch" href="/matt-blog/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/matt-blog/assets/css/0.styles.67df34d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/matt-blog/" class="home-link router-link-active"><img src="/matt-blog/cainiao.jpg" alt="matt的前端之路" class="logo"> <span class="site-name can-hide">matt的前端之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hybrid</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>mini-program</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/matt-blog/pages/mini-program/taro.html" aria-current="page" class="active sidebar-link">Taro 框架深度解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/matt-blog/pages/mini-program/taro.html#核心思想" class="sidebar-link">核心思想</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/mini-program/taro.html#babel-生态系统" class="sidebar-link">Babel 生态系统</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/mini-program/taro.html#taro-代码转换机制" class="sidebar-link">Taro 代码转换机制</a></li><li class="sidebar-sub-header"><a href="/matt-blog/pages/mini-program/taro.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>performance</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目经验剖析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>qwik</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-native</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>rust</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>xiaochengxu</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="taro-框架深度解析"><a href="#taro-框架深度解析" class="header-anchor">#</a> Taro 框架深度解析</h1> <p>Taro 是一套遵循 React 语法规范的多端开发解决方案。本文将深入探讨 Taro 的核心原理和代码转换机制。</p> <h2 id="核心思想"><a href="#核心思想" class="header-anchor">#</a> 核心思想</h2> <p>不管是任意语言的代码，其实它们都有两个共同点：</p> <ol><li><strong>它们都是由字符串构成的文本</strong></li> <li><strong>它们都要遵循自己的语言规范</strong></li></ol> <p>基于这两个特点，Taro 通过编译时和运行时的结合，实现了一套代码多端运行的能力。</p> <h2 id="babel-生态系统"><a href="#babel-生态系统" class="header-anchor">#</a> Babel 生态系统</h2> <p>Taro 选择 Babel 作为代码转换的基础工具，主要有以下优势：</p> <ol><li><strong>语法前瞻性</strong>: Babel 可以解析还没有进入 ECMAScript 规范的语法，例如装饰器这样的提案</li> <li><strong>语言扩展性</strong>: 提供插件机制解析 TypeScript、Flow、JSX 这样的 JavaScript 超集</li> <li><strong>丰富生态</strong>: 拥有庞大的生态，有非常多的文档和样例代码可供参考</li> <li><strong>工具完备性</strong>: 除去 parser 本身，Babel 还提供各种方便的工具库可以优化、生成、调试代码</li></ol> <h3 id="babylon-babel-parser"><a href="#babylon-babel-parser" class="header-anchor">#</a> Babylon (@babel/parser)</h3> <p>Babylon 是 Babel 的 JavaScript 解析器，负责将代码转换为抽象语法树（AST）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> babylon <span class="token keyword">from</span> <span class="token string">&quot;babylon&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">n * n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

babylon<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>解析结果会生成如下的 AST 结构：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/544808/1600046669718-0f3a5112-4ae0-483f-bbee-613558bb908c.png" alt="AST 结构图"></p> <h3 id="babel-traverse-babel-traverse"><a href="#babel-traverse-babel-traverse" class="header-anchor">#</a> Babel-traverse (@babel/traverse)</h3> <p><code>babel-traverse</code> 是 Babel 生态中最核心的模块，它的主要功能包括：</p> <ul><li><strong>AST 遍历</strong>: 可以遍历由 Babylon 生成的抽象语法树</li> <li><strong>路径转换</strong>: 把抽象语法树的各个节点从拓扑数据结构转化成一颗路径（Path）树</li> <li><strong>响应式操作</strong>: Path 表示两个节点之间连接的响应式（Reactive）对象，拥有添加、删除、替换节点等方法</li> <li><strong>作用域处理</strong>: 提供操作作用域（Scope）和标识符绑定（Identifier Binding）的方法</li></ul> <p>当你调用这些修改树的方法之后，路径信息也会被更新，这使得复杂的代码转换变得可能。</p> <h3 id="babel-types"><a href="#babel-types" class="header-anchor">#</a> Babel-types</h3> <p><code>babel-types</code> 是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。</p> <p>例如，我们可以使用 <code>babel-types</code> 来简化标识符的改变：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> traverse <span class="token keyword">from</span> <span class="token string">&quot;babel-traverse&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> t <span class="token keyword">from</span> <span class="token string">&quot;babel-types&quot;</span><span class="token punctuation">;</span>

<span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isIdentifier</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>node<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;n&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      path<span class="token punctuation">.</span>node<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;x&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用 <code>babel-types</code> 能显著提高代码转换的可读性。在配合 TypeScript 这样的静态类型语言后，<code>babel-types</code> 的方法还能提供类型校验功能，有效提高转换代码的健壮性和可靠性。</p> <h2 id="taro-代码转换机制"><a href="#taro-代码转换机制" class="header-anchor">#</a> Taro 代码转换机制</h2> <h3 id="整体设计思路"><a href="#整体设计思路" class="header-anchor">#</a> 整体设计思路</h3> <p>Taro 的架构主要分为两个方面：<strong>运行时</strong>和<strong>编译时</strong>。</p> <h4 id="运行时-runtime"><a href="#运行时-runtime" class="header-anchor">#</a> 运行时 (Runtime)</h4> <p>运行时负责把编译后的代码运行在本不能运行的对应环境中，你可以把 Taro 运行时理解为前端开发中的 <code>polyfill</code>。</p> <p>举例来说，小程序新建一个页面是使用 <code>Page</code> 方法传入一个字面量对象，并不支持使用类。如果全部依赖编译时的话，那么我们要做的事情大概就是：</p> <ul><li>把类转化成对象</li> <li>把 <code>state</code> 变为 <code>data</code></li> <li>把生命周期如 <code>componentDidMount</code> 转化成 <code>onReady</code></li> <li>把事件由可能的类函数和类属性函数转化成字面量对象方法</li></ul> <p>但这显然会让编译时工作变得非常繁重，在一个类异常复杂时出错的概率也会变高。</p> <h4 id="更优雅的解决方案"><a href="#更优雅的解决方案" class="header-anchor">#</a> 更优雅的解决方案</h4> <p>我们有更好的办法：实现一个 <code>createPage</code> 方法，接受一个类作为参数，返回一个小程序 <code>Page</code> 方法所需要的字面量对象。</p> <p>这样做的好处：</p> <ul><li><strong>简化编译时工作</strong>: 编译时只需要在文件底部加上一行代码 <code>Page(createPage(componentName))</code></li> <li><strong>运行时优化</strong>: 可以在 <code>createPage</code> 对编译时产出的类做各种操作和优化</li> <li><strong>职责分离</strong>: 通过运行时把工作分离，使整个架构更加清晰</li></ul> <h3 id="render-函数转换"><a href="#render-函数转换" class="header-anchor">#</a> render() 函数转换</h3> <p>在 Taro 中，<code>render()</code> 函数有着特殊的处理机制。考虑下面的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> oddNumbers <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>numbers<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">number</span> <span class="token operator">=&gt;</span> number <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 其他代码...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的 <code>oddNumbers</code> 通过 <code>filter</code> 把数字数组的所有偶数项都过滤掉，真正用来循环的是 <code>oddNumbers</code>，而 <code>oddNumbers</code> 并没有在 <code>this.state</code> 中，所以我们必须手动把它加入到 <code>this.state</code>。</p> <p>和 React 的区别：</p> <ul><li><strong>React</strong>: <code>render</code> 是一个创建虚拟 DOM 的方法</li> <li><strong>Taro</strong>: <code>render</code> 会被重命名为 <code>_createData</code>，它是一个创建数据的方法</li></ul> <p>在 JSX 中使用过的数据都在这里被创建，最后放到小程序 <code>Page</code> 或 <code>Component</code> 工厂方法中的 <code>data</code>。</p> <p>最终编译结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">_createData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>__state <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>__props <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> oddNumbers <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__state<span class="token punctuation">.</span>numbers<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">number</span> <span class="token operator">=&gt;</span> number <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>__state<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">oddNumbers</span><span class="token operator">:</span> oddNumbers
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__state<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="生命周期转换"><a href="#生命周期转换" class="header-anchor">#</a> 生命周期转换</h3> <p>React 组件的生命周期需要转换为小程序对应的生命周期：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/544808/1600048283636-967ecc1c-7555-4b01-8701-eaa8534134b8.png" alt="生命周期转换图"></p> <h3 id="状态更新机制"><a href="#状态更新机制" class="header-anchor">#</a> 状态更新机制</h3> <p>Taro 的状态更新需要适配小程序的数据更新机制：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/544808/1600048306438-a6403e5c-3aa7-4339-8cbe-646e82e1afad.png" alt="状态更新图"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Taro 通过巧妙的编译时和运行时结合，实现了以下目标：</p> <ol><li><strong>语法统一</strong>: 使用 React 语法编写一套代码</li> <li><strong>多端运行</strong>: 编译到不同平台的原生代码</li> <li><strong>性能优化</strong>: 通过运行时适配各平台特性</li> <li><strong>开发体验</strong>: 保持了 React 开发者熟悉的开发方式</li></ol> <p>这种设计使得开发者可以用熟悉的 React 语法开发小程序，同时保证了较好的性能和平台兼容性。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/matt-blog/pages/hybrid/jsbridge.html" class="prev">
        jsbridge原理浅析
      </a></span> <span class="next"><a href="/matt-blog/pages/network/https.html">
        浅析https
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/matt-blog/assets/js/app.71e86090.js" defer></script><script src="/matt-blog/assets/js/2.778bb4ad.js" defer></script><script src="/matt-blog/assets/js/1.f8bb34da.js" defer></script><script src="/matt-blog/assets/js/24.d02ac95a.js" defer></script>
  </body>
</html>
