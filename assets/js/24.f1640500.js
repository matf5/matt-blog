(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{311:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"taro-框架深度解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#taro-框架深度解析"}},[t._v("#")]),t._v(" Taro 框架深度解析")]),t._v(" "),a("p",[t._v("Taro 是一套遵循 React 语法规范的多端开发解决方案。本文将深入探讨 Taro 的核心原理和代码转换机制。")]),t._v(" "),a("h2",{attrs:{id:"核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[t._v("#")]),t._v(" 核心思想")]),t._v(" "),a("p",[t._v("不管是任意语言的代码，其实它们都有两个共同点：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("它们都是由字符串构成的文本")])]),t._v(" "),a("li",[a("strong",[t._v("它们都要遵循自己的语言规范")])])]),t._v(" "),a("p",[t._v("基于这两个特点，Taro 通过编译时和运行时的结合，实现了一套代码多端运行的能力。")]),t._v(" "),a("h2",{attrs:{id:"babel-生态系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-生态系统"}},[t._v("#")]),t._v(" Babel 生态系统")]),t._v(" "),a("p",[t._v("Taro 选择 Babel 作为代码转换的基础工具，主要有以下优势：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("语法前瞻性")]),t._v(": Babel 可以解析还没有进入 ECMAScript 规范的语法，例如装饰器这样的提案")]),t._v(" "),a("li",[a("strong",[t._v("语言扩展性")]),t._v(": 提供插件机制解析 TypeScript、Flow、JSX 这样的 JavaScript 超集")]),t._v(" "),a("li",[a("strong",[t._v("丰富生态")]),t._v(": 拥有庞大的生态，有非常多的文档和样例代码可供参考")]),t._v(" "),a("li",[a("strong",[t._v("工具完备性")]),t._v(": 除去 parser 本身，Babel 还提供各种方便的工具库可以优化、生成、调试代码")])]),t._v(" "),a("h3",{attrs:{id:"babylon-babel-parser"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babylon-babel-parser"}},[t._v("#")]),t._v(" Babylon (@babel/parser)")]),t._v(" "),a("p",[t._v("Babylon 是 Babel 的 JavaScript 解析器，负责将代码转换为抽象语法树（AST）。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" babylon "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"babylon"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" code "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("n * n")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nbabylon"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("解析结果会生成如下的 AST 结构：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/544808/1600046669718-0f3a5112-4ae0-483f-bbee-613558bb908c.png",alt:"AST 结构图"}})]),t._v(" "),a("h3",{attrs:{id:"babel-traverse-babel-traverse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-traverse-babel-traverse"}},[t._v("#")]),t._v(" Babel-traverse (@babel/traverse)")]),t._v(" "),a("p",[a("code",[t._v("babel-traverse")]),t._v(" 是 Babel 生态中最核心的模块，它的主要功能包括：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("AST 遍历")]),t._v(": 可以遍历由 Babylon 生成的抽象语法树")]),t._v(" "),a("li",[a("strong",[t._v("路径转换")]),t._v(": 把抽象语法树的各个节点从拓扑数据结构转化成一颗路径（Path）树")]),t._v(" "),a("li",[a("strong",[t._v("响应式操作")]),t._v(": Path 表示两个节点之间连接的响应式（Reactive）对象，拥有添加、删除、替换节点等方法")]),t._v(" "),a("li",[a("strong",[t._v("作用域处理")]),t._v(": 提供操作作用域（Scope）和标识符绑定（Identifier Binding）的方法")])]),t._v(" "),a("p",[t._v("当你调用这些修改树的方法之后，路径信息也会被更新，这使得复杂的代码转换变得可能。")]),t._v(" "),a("h3",{attrs:{id:"babel-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-types"}},[t._v("#")]),t._v(" Babel-types")]),t._v(" "),a("p",[a("code",[t._v("babel-types")]),t._v(" 是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。")]),t._v(" "),a("p",[t._v("例如，我们可以使用 "),a("code",[t._v("babel-types")]),t._v(" 来简化标识符的改变：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" traverse "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"babel-traverse"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" t "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"babel-types"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("enter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isIdentifier")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"n"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"x"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("使用 "),a("code",[t._v("babel-types")]),t._v(" 能显著提高代码转换的可读性。在配合 TypeScript 这样的静态类型语言后，"),a("code",[t._v("babel-types")]),t._v(" 的方法还能提供类型校验功能，有效提高转换代码的健壮性和可靠性。")]),t._v(" "),a("h2",{attrs:{id:"taro-代码转换机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#taro-代码转换机制"}},[t._v("#")]),t._v(" Taro 代码转换机制")]),t._v(" "),a("h3",{attrs:{id:"整体设计思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整体设计思路"}},[t._v("#")]),t._v(" 整体设计思路")]),t._v(" "),a("p",[t._v("Taro 的架构主要分为两个方面："),a("strong",[t._v("运行时")]),t._v("和"),a("strong",[t._v("编译时")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"运行时-runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行时-runtime"}},[t._v("#")]),t._v(" 运行时 (Runtime)")]),t._v(" "),a("p",[t._v("运行时负责把编译后的代码运行在本不能运行的对应环境中，你可以把 Taro 运行时理解为前端开发中的 "),a("code",[t._v("polyfill")]),t._v("。")]),t._v(" "),a("p",[t._v("举例来说，小程序新建一个页面是使用 "),a("code",[t._v("Page")]),t._v(" 方法传入一个字面量对象，并不支持使用类。如果全部依赖编译时的话，那么我们要做的事情大概就是：")]),t._v(" "),a("ul",[a("li",[t._v("把类转化成对象")]),t._v(" "),a("li",[t._v("把 "),a("code",[t._v("state")]),t._v(" 变为 "),a("code",[t._v("data")])]),t._v(" "),a("li",[t._v("把生命周期如 "),a("code",[t._v("componentDidMount")]),t._v(" 转化成 "),a("code",[t._v("onReady")])]),t._v(" "),a("li",[t._v("把事件由可能的类函数和类属性函数转化成字面量对象方法")])]),t._v(" "),a("p",[t._v("但这显然会让编译时工作变得非常繁重，在一个类异常复杂时出错的概率也会变高。")]),t._v(" "),a("h4",{attrs:{id:"更优雅的解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更优雅的解决方案"}},[t._v("#")]),t._v(" 更优雅的解决方案")]),t._v(" "),a("p",[t._v("我们有更好的办法：实现一个 "),a("code",[t._v("createPage")]),t._v(" 方法，接受一个类作为参数，返回一个小程序 "),a("code",[t._v("Page")]),t._v(" 方法所需要的字面量对象。")]),t._v(" "),a("p",[t._v("这样做的好处：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("简化编译时工作")]),t._v(": 编译时只需要在文件底部加上一行代码 "),a("code",[t._v("Page(createPage(componentName))")])]),t._v(" "),a("li",[a("strong",[t._v("运行时优化")]),t._v(": 可以在 "),a("code",[t._v("createPage")]),t._v(" 对编译时产出的类做各种操作和优化")]),t._v(" "),a("li",[a("strong",[t._v("职责分离")]),t._v(": 通过运行时把工作分离，使整个架构更加清晰")])]),t._v(" "),a("h3",{attrs:{id:"render-函数转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-函数转换"}},[t._v("#")]),t._v(" render() 函数转换")]),t._v(" "),a("p",[t._v("在 Taro 中，"),a("code",[t._v("render()")]),t._v(" 函数有着特殊的处理机制。考虑下面的例子：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" oddNumbers "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("numbers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("number")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 其他代码...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这里的 "),a("code",[t._v("oddNumbers")]),t._v(" 通过 "),a("code",[t._v("filter")]),t._v(" 把数字数组的所有偶数项都过滤掉，真正用来循环的是 "),a("code",[t._v("oddNumbers")]),t._v("，而 "),a("code",[t._v("oddNumbers")]),t._v(" 并没有在 "),a("code",[t._v("this.state")]),t._v(" 中，所以我们必须手动把它加入到 "),a("code",[t._v("this.state")]),t._v("。")]),t._v(" "),a("p",[t._v("和 React 的区别：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("React")]),t._v(": "),a("code",[t._v("render")]),t._v(" 是一个创建虚拟 DOM 的方法")]),t._v(" "),a("li",[a("strong",[t._v("Taro")]),t._v(": "),a("code",[t._v("render")]),t._v(" 会被重命名为 "),a("code",[t._v("_createData")]),t._v("，它是一个创建数据的方法")])]),t._v(" "),a("p",[t._v("在 JSX 中使用过的数据都在这里被创建，最后放到小程序 "),a("code",[t._v("Page")]),t._v(" 或 "),a("code",[t._v("Component")]),t._v(" 工厂方法中的 "),a("code",[t._v("data")]),t._v("。")]),t._v(" "),a("p",[t._v("最终编译结果：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("_createData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" oddNumbers "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("numbers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("number")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("assign")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("oddNumbers")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" oddNumbers\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"生命周期转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期转换"}},[t._v("#")]),t._v(" 生命周期转换")]),t._v(" "),a("p",[t._v("React 组件的生命周期需要转换为小程序对应的生命周期：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/544808/1600048283636-967ecc1c-7555-4b01-8701-eaa8534134b8.png",alt:"生命周期转换图"}})]),t._v(" "),a("h3",{attrs:{id:"状态更新机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态更新机制"}},[t._v("#")]),t._v(" 状态更新机制")]),t._v(" "),a("p",[t._v("Taro 的状态更新需要适配小程序的数据更新机制：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/544808/1600048306438-a6403e5c-3aa7-4339-8cbe-646e82e1afad.png",alt:"状态更新图"}})]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("Taro 通过巧妙的编译时和运行时结合，实现了以下目标：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("语法统一")]),t._v(": 使用 React 语法编写一套代码")]),t._v(" "),a("li",[a("strong",[t._v("多端运行")]),t._v(": 编译到不同平台的原生代码")]),t._v(" "),a("li",[a("strong",[t._v("性能优化")]),t._v(": 通过运行时适配各平台特性")]),t._v(" "),a("li",[a("strong",[t._v("开发体验")]),t._v(": 保持了 React 开发者熟悉的开发方式")])]),t._v(" "),a("p",[t._v("这种设计使得开发者可以用熟悉的 React 语法开发小程序，同时保证了较好的性能和平台兼容性。")])])}),[],!1,null,null,null);a.default=e.exports}}]);