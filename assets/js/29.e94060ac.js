(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{310:function(t,a,e){"use strict";e.r(a);var s=e(14),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"cargo-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cargo-lock"}},[t._v("#")]),t._v(" cargo.lock")]),t._v(" "),a("ol",[a("li",[t._v("首次安装时自动使用当前大版本的最新版本")]),t._v(" "),a("li",[t._v("一旦lock存在, 后续每次都是使用lock中的版本")]),t._v(" "),a("li",[t._v("需要更新可以用cargo update")])]),t._v(" "),a("h1",{attrs:{id:"view-doc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#view-doc"}},[t._v("#")]),t._v(" view doc")]),t._v(" "),a("p",[t._v("cargo doc --open")]),t._v(" "),a("h1",{attrs:{id:"mismatched-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mismatched-type"}},[t._v("#")]),t._v(" mismatched type")]),t._v(" "),a("p",[t._v("Rust有静态强类型系统, 可以进行类型推断")]),t._v(" "),a("h1",{attrs:{id:"shadow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shadow"}},[t._v("#")]),t._v(" shadow")]),t._v(" "),a("p",[t._v("rust允许新值覆盖之前的值")]),t._v(" "),a("h2",{attrs:{id:"mut-和shadow的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mut-和shadow的区别"}},[t._v("#")]),t._v(" mut 和shadow的区别")]),t._v(" "),a("p",[t._v("shadow可以重复使用相同的变量名称")]),t._v(" "),a("h1",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("h2",{attrs:{id:"整数类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整数类型"}},[t._v("#")]),t._v(" 整数类型")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/matf5/fileCache/master/20240425160121.png",alt:"20240425160121"}})]),t._v(" "),a("p",[t._v("默认会使用i32")]),t._v(" "),a("h2",{attrs:{id:"浮点类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点类型"}},[t._v("#")]),t._v(" 浮点类型")]),t._v(" "),a("h3",{attrs:{id:"单精度-f32"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单精度-f32"}},[t._v("#")]),t._v(" 单精度 f32")]),t._v(" "),a("h3",{attrs:{id:"双精度-f64-默认"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双精度-f64-默认"}},[t._v("#")]),t._v(" 双精度 f64(默认)")]),t._v(" "),a("h2",{attrs:{id:"布尔类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型"}},[t._v("#")]),t._v(" 布尔类型")]),t._v(" "),a("p",[t._v("true 和false")]),t._v(" "),a("h2",{attrs:{id:"字符类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符类型"}},[t._v("#")]),t._v(" 字符类型")]),t._v(" "),a("h2",{attrs:{id:"符合类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#符合类型"}},[t._v("#")]),t._v(" 符合类型")]),t._v(" "),a("h3",{attrs:{id:"元组tuple"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元组tuple"}},[t._v("#")]),t._v(" 元组tuple")]),t._v(" "),a("ul",[a("li",[t._v("长度是固定的")]),t._v(" "),a("li",[t._v("支持解构")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    println!("The value of y is: {}", y);\n}\n')])])]),a("ul",[a("li",[t._v("索引访问")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn main() {\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n}\n")])])]),a("ul",[a("li",[t._v("()是一种特殊的类型(没有任何值), 该类型被称为单元类型, 如果表达式不返回任何其他值，就隐式地返回单元值, 有点类似void()默认返回undefined")])]),t._v(" "),a("h3",{attrs:{id:"数组array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组array"}},[t._v("#")]),t._v(" 数组array")]),t._v(" "),a("ul",[a("li",[t._v("长度是固定的")]),t._v(" "),a("li",[t._v("每个元素必须拥有相同类型")]),t._v(" "),a("li",[t._v("如果要长度不固定可以使用vector")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = [3:5]; 表示let a = [3, 3, 3, 3, 3]\n")])])]),a("h1",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("p",[t._v("与javascript类似")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn main() {\n    let y = 6;\n}\n")])])]),a("h2",{attrs:{id:"语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语句"}},[t._v("#")]),t._v(" 语句")]),t._v(" "),a("p",[t._v("执行操作但不返回值")]),t._v(" "),a("h2",{attrs:{id:"表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表达式"}},[t._v("#")]),t._v(" 表达式")]),t._v(" "),a("ul",[a("li",[t._v("计算并产生一个值")]),t._v(" "),a("li",[t._v("表达式的结尾没有分号")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!("The value of y is: {}", y);\n}\n')])])]),a("h1",{attrs:{id:"控制流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制流"}},[t._v("#")]),t._v(" 控制流")]),t._v(" "),a("h2",{attrs:{id:"if表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if表达式"}},[t._v("#")]),t._v(" if表达式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!("number is divisible by 4");\n    } else if number % 3 == 0 {\n        println!("number is divisible by 3");\n    } else if number % 2 == 0 {\n        println!("number is divisible by 2");\n    } else {\n        println!("number is not divisible by 4, 3, or 2");\n    }\n}\n')])])]),a("h3",{attrs:{id:"let中也可以使用if"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let中也可以使用if"}},[t._v("#")]),t._v(" let中也可以使用if")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!("The value of number is: {}", number);\n}\n')])])]),a("h2",{attrs:{id:"loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loop"}},[t._v("#")]),t._v(" loop")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let mut count = 0;\n    \'counting_up: loop {\n        println!("count = {}", count);\n        let mut remaining = 10;\n\n        loop {\n            println!("remaining = {}", remaining);\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break \'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!("End count = {}", count);\n}\n')])])]),a("h3",{attrs:{id:"从循环返回"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从循环返回"}},[t._v("#")]),t._v(" 从循环返回")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!("The result is {}", result);\n}\n')])])]),a("h2",{attrs:{id:"while"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#while"}},[t._v("#")]),t._v(" while")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!("{}!", number);\n\n        number -= 1;\n    }\n\n    println!("LIFTOFF!!!");\n}\n')])])]),a("h2",{attrs:{id:"for"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for"}},[t._v("#")]),t._v(" for")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!("the value is: {}", element);\n    }\n}\n')])])]),a("h1",{attrs:{id:"所有权-ownership"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权-ownership"}},[t._v("#")]),t._v(" 所有权(ownership)")]),t._v(" "),a("ul",[a("li",[t._v("Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。")]),t._v(" "),a("li",[t._v("值在任一时刻有且只有一个所有者。")]),t._v(" "),a("li",[t._v("当所有者（变量）离开作用域，这个值将被丢弃。")])]),t._v(" "),a("h2",{attrs:{id:"变量作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量作用域"}},[t._v("#")]),t._v(" 变量作用域")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('    {                      // s 在这里无效, 它尚未声明\n        let s = "hello";   // 从此处起，s 开始有效\n\n        // 使用 s\n    }                      // 此作用域已结束，s 不再有效\n')])])]),a("h2",{attrs:{id:"string类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string类型"}},[t._v("#")]),t._v(" String类型")]),t._v(" "),a("p",[t._v("管理被分配到堆上的数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  let mut s = String::from("hello");\n\n    s.push_str(", world!"); // push_str() 在字符串后追加字面值\n\n    println!("{}", s); // 将打印 `hello, world!`\n')])])]),a("h2",{attrs:{id:"数据交互方式一-move"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据交互方式一-move"}},[t._v("#")]),t._v(" 数据交互方式一: Move")]),t._v(" "),a("p",[t._v("对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：")]),t._v(" "),a("ul",[a("li",[t._v("必须在运行时向内存分配器请求内存。")]),t._v(" "),a("li",[t._v("需要一个当我们处理完 String 时将内存返回给分配器的方法。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  let s1 = String::from("hello");\n  let s2 = s1;\n')])])]),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/matf5/fileCache/master/20240425163816.png",alt:"20240425163816"}})]),t._v(" "),a("p",[t._v("左侧为栈, 右侧为堆")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/matf5/fileCache/master/20240425164109.png",alt:"20240425164109"}})]),t._v(" "),a("p",[t._v("移动之后只有s2有效, s1会被释放")]),t._v(" "),a("p",[t._v("Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。")]),t._v(" "),a("h3",{attrs:{id:"长度和容量的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长度和容量的区别是什么"}},[t._v("#")]),t._v(" 长度和容量的区别是什么?")]),t._v(" "),a("p",[t._v("长度表示 "),a("code",[t._v("String")]),t._v(" 的内容当前使用了多少字节的内存。容量是 "),a("code",[t._v("String")]),t._v(" 从分配器总共获取了多少字节的内容")]),t._v(" "),a("h2",{attrs:{id:"数据交互方式二-clone"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据交互方式二-clone"}},[t._v("#")]),t._v(" 数据交互方式二: Clone")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('   let s1 = String::from("hello");\n   let s2 = s1.clone();\n\n  println!("s1 = {}, s2 = {}", s1, s2);\n')])])]),a("h2",{attrs:{id:"只在栈上的数据-拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#只在栈上的数据-拷贝"}},[t._v("#")]),t._v(" 只在栈上的数据: 拷贝")]),t._v(" "),a("h3",{attrs:{id:"copy-trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy-trait"}},[t._v("#")]),t._v(" copy trait")]),t._v(" "),a("p",[t._v("如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用")]),t._v(" "),a("h3",{attrs:{id:"实现了copy-trait的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现了copy-trait的类型"}},[t._v("#")]),t._v(" 实现了copy trait的类型")]),t._v(" "),a("ul",[a("li",[t._v("所有整数类型，比如 u32。")]),t._v(" "),a("li",[t._v("布尔类型，bool，它的值是 true 和 false。")]),t._v(" "),a("li",[t._v("所有浮点数类型，比如 f64。")]),t._v(" "),a("li",[t._v("字符类型，char。")]),t._v(" "),a("li",[t._v("元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。")])]),t._v(" "),a("h2",{attrs:{id:"所有权与函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权与函数"}},[t._v("#")]),t._v(" 所有权与函数")]),t._v(" "),a("p",[t._v("将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n  let s = String::from("hello");  // s 进入作用域\n\n  takes_ownership(s);             // s 的值移动到函数里 ...\n                                  // ... 所以到这里不再有效\n\n  let x = 5;                      // x 进入作用域\n\n  makes_copy(x);                  // x 应该移动函数里，\n                                  // 但 i32 是 Copy 的，所以在后面可继续使用 x\n\n} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，\n  // 所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n  println!("{}", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n  println!("{}", some_integer);\n} // 这里，some_integer 移出作用域。不会有特殊操作\n')])])]),a("h2",{attrs:{id:"返回值与作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回值与作用域"}},[t._v("#")]),t._v(" 返回值与作用域")]),t._v(" "),a("p",[t._v("返回值也可以转移所有权。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n  let s1 = gives_ownership();         // gives_ownership 将返回值\n                                      // 移给 s1\n\n  let s2 = String::from("hello");     // s2 进入作用域\n\n  let s3 = takes_and_gives_back(s2);  // s2 被移动到\n                                      // takes_and_gives_back 中,\n                                      // 它也将返回值移给 s3\n} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，\n  // 所以什么也不会发生。s1 移出作用域并被丢弃\n\nfn gives_ownership() -> String {           // gives_ownership 将返回值移动给\n                                           // 调用它的函数\n\n  let some_string = String::from("yours"); // some_string 进入作用域\n\n  some_string                              // 返回 some_string 并移出给调用的函数\n}\n\n// takes_and_gives_back 将传入字符串并返回该值\nfn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域\n\n  a_string  // 返回 a_string 并移出给调用的函数\n}\n')])])]),a("h1",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用")]),t._v(" "),a("p",[t._v("以一个对象的引用作为参数而不是获取值的所有权")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let s1 = String::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n')])])]),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/matf5/fileCache/master/20240425165744.png",alt:"20240425165744"}})]),t._v(" "),a("h2",{attrs:{id:"可变引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可变引用"}},[t._v("#")]),t._v(" 可变引用")]),t._v(" "),a("p",[t._v("正常引用是不可变的, 无法通过引用修改内容\n如果要可变, 可以修改为mut")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n')])])]),a("p",[t._v("在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('   let mut s = String::from("hello");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!("{}, {}", r1, r2);\n')])])]),a("p",[t._v("以下代码没问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('    let mut s = String::from("hello");\n\n    let r1 = &s; // 没问题\n    let r2 = &s; // 没问题\n    println!("{} and {}", r1, r2);\n    // 此位置之后 r1 和 r2 不再使用\n\n    let r3 = &mut s; // 没问题\n    println!("{}", r3);\n')])])]),a("h2",{attrs:{id:"悬垂引用-dangling-references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悬垂引用-dangling-references"}},[t._v("#")]),t._v(" 悬垂引用（Dangling References）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from("hello");\n\n    &s // 这里s离开作用域已经被释放掉了\n}\n')])])]),a("h2",{attrs:{id:"引用的规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用的规则"}},[t._v("#")]),t._v(" 引用的规则")]),t._v(" "),a("ul",[a("li",[t._v("在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。")]),t._v(" "),a("li",[t._v("引用必须总是有效的。")])]),t._v(" "),a("h2",{attrs:{id:"解引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解引用"}},[t._v("#")]),t._v(" 解引用 (*)")]),t._v(" "),a("h1",{attrs:{id:"切片-slice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#切片-slice"}},[t._v("#")]),t._v(" 切片(slice)")]),t._v(" "),a("h2",{attrs:{id:"字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  let s = String::from("hello world");\n\n  let hello = &s[0..5];\n  let world = &s[6..11];\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let my_string = String::from("hello world");\n\n    // `first_word` 接受 `String` 的切片，无论是部分还是全部\n    let word = first_word(&my_string[0..6]);\n    let word = first_word(&my_string[..]);\n    // `first_word` 也接受 `String` 的引用，\n    // 这等同于 `String` 的全部切片\n    let word = first_word(&my_string);\n\n    let my_string_literal = "hello world";\n\n    // `first_word` 接受字符串字面量的切片，无论是部分还是全部\n    let word = first_word(&my_string_literal[0..6]);\n    let word = first_word(&my_string_literal[..]);\n\n    // 因为字符串字面值**就是**字符串 slice，\n    // 这样写也可以，即不使用 slice 语法！\n    let word = first_word(my_string_literal);\n}\n')])])]),a("h2",{attrs:{id:"其他类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他类型"}},[t._v("#")]),t._v(" 其他类型")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n")])])]),a("h1",{attrs:{id:"struct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct"}},[t._v("#")]),t._v(" struct")]),t._v(" "),a("p",[t._v("或者 structure，是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let user1 = User {\n        email: String::from("someone@example.com"),\n        username: String::from("someusername123"),\n        active: true,\n        sign_in_count: 1,\n    };\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 简洁写法类似Javascript\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    // 两个.\n\n    let user2 = User {\n        email: String::from("another@example.com"),\n        ..user1\n    };\n    // 发生了Move. 不能再使用user1了\n}\n')])])]),a("h2",{attrs:{id:"tuple-struct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tuple-struct"}},[t._v("#")]),t._v(" tuple struct")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n")])])]),a("h2",{attrs:{id:"trait-功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trait-功能"}},[t._v("#")]),t._v(" trait 功能")]),t._v(" "),a("p",[t._v("在 {} 中加入 :? 指示符告诉 println! 我们想要使用叫做 Debug 的输出格式。Debug 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体，以便当我们调试代码时能看到它的值。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!("rect1 is {:?}", rect1);\n}\n')])])]),a("p",[t._v("{:#?} 格式化更明显")]),t._v(" "),a("h2",{attrs:{id:"dbg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dbg"}},[t._v("#")]),t._v(" dbg!")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n")])])]),a("h2",{attrs:{id:"方法语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法语法"}},[t._v("#")]),t._v(" 方法语法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    // &self 实际上是 self: &Self 的缩写\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        "The area of the rectangle is {} square pixels.",\n        rect1.area()\n    );\n}\n')])])]),a("h1",{attrs:{id:"enums"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enums"}},[t._v("#")]),t._v(" enums")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from("::1"));\n')])])]),a("h2",{attrs:{id:"option"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option"}},[t._v("#")]),t._v(" option")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum Option<T> {\n    Some(T),\n    None,\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let some_number = Some(5);\nlet some_string = Some("a string");\n\nlet absent_number: Option<i32> = None;\n')])])]),a("h2",{attrs:{id:"match"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#match"}},[t._v("#")]),t._v(" match")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('#[derive(Debug)] // 这样可以立刻看到州的名称\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!("State quarter from {:?}!", state);\n            25\n        }\n    }\n}\n')])])]),a("h2",{attrs:{id:"匹配options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#匹配options"}},[t._v("#")]),t._v(" 匹配Options")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n")])])]),a("h2",{attrs:{id:"other和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other和"}},[t._v("#")]),t._v(" other和_")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n")])])]),a("h2",{attrs:{id:"if-let"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-let"}},[t._v("#")]),t._v(" if let")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!("State quarter from {:?}!", state);\n} else {\n    count += 1;\n}\n')])])]),a("h1",{attrs:{id:"项目结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目结构"}},[t._v("#")]),t._v(" 项目结构")]),t._v(" "),a("ul",[a("li",[t._v("包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。")]),t._v(" "),a("li",[t._v("Crates ：一个模块的树形结构，它形成了库或二进制项目。")]),t._v(" "),a("li",[t._v("模块（Modules）和 use： 允许你控制作用域和路径的私有性。")]),t._v(" "),a("li",[t._v("路径（path）：一个命名例如结构体、函数或模块等项的方式")])]),t._v(" "),a("h2",{attrs:{id:"包和crate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包和crate"}},[t._v("#")]),t._v(" 包和crate")]),t._v(" "),a("p",[t._v("一个包中至多 只能 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的。")]),t._v(" "),a("h3",{attrs:{id:"二进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制"}},[t._v("#")]),t._v(" 二进制")]),t._v(" "),a("ul",[a("li",[t._v("单个 src/main.rs")]),t._v(" "),a("li",[t._v("多个 src/bin/xxx.rs")])]),t._v(" "),a("h3",{attrs:{id:"库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#库"}},[t._v("#")]),t._v(" 库")]),t._v(" "),a("ul",[a("li",[t._v("src/lib.rs")])]),t._v(" "),a("h2",{attrs:{id:"模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[t._v("#")]),t._v(" 模块")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("mod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n")])])]),a("h2",{attrs:{id:"路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路径"}},[t._v("#")]),t._v(" 路径")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("mod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // 绝对路径\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    front_of_house::hosting::add_to_waitlist();\n}\n")])])]),a("h3",{attrs:{id:"绝对路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绝对路径"}},[t._v("#")]),t._v(" 绝对路径")]),t._v(" "),a("p",[t._v("从 crate 根部开始，以 crate 名或者字面量 crate 开头。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("crate::xxx\n")])])]),a("h3",{attrs:{id:"相对路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相对路径"}},[t._v("#")]),t._v(" 相对路径")]),t._v(" "),a("p",[t._v("从当前模块开始，以 self、super 或当前模块的标识符开头。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn serve_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n\n    fn cook_order() {}\n}\n")])])]),a("h2",{attrs:{id:"use"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#use"}},[t._v("#")]),t._v(" use")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("mod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n")])])]),a("h2",{attrs:{id:"嵌套路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#嵌套路径"}},[t._v("#")]),t._v(" 嵌套路径")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("use std::cmp::Ordering;\nuse std::io;\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("use std::{cmp::Ordering, io};\n")])])]),a("h1",{attrs:{id:"vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[t._v("#")]),t._v(" vector")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let v: Vec<i32> = Vec::new();\n\nlet v2 = vec![1, 2, 3];\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let mut v = Vec::new();\n\nv.push(5);\nv.push(6);\nv.push(7);\nv.push(8);\n")])])]),a("h2",{attrs:{id:"读取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读取"}},[t._v("#")]),t._v(" 读取")]),t._v(" "),a("p",[t._v("索引或者get")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist = &v[100];\nlet does_not_exist = v.get(100);\n")])])]),a("h2",{attrs:{id:"遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[t._v("#")]),t._v(" 遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let v = vec![100, 32, 57];\nfor i in &v {\n    println!("{}", i);\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let mut v = vec![100, 32, 57];\nfor i in &mut v {\n    *i += 50;\n}\n")])])]),a("h2",{attrs:{id:"枚举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[t._v("#")]),t._v(" 枚举")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('enum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from("blue")),\n    SpreadsheetCell::Float(10.12),\n];\n')])])]),a("h1",{attrs:{id:"字符串-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串-2"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),a("h2",{attrs:{id:"新建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新建"}},[t._v("#")]),t._v(" 新建")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let mut s = String::new();\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\nlet data = "initial contents";\n\nlet s = data.to_string();\n\n// 该方法也可直接用于字符串字面量：\nlet s = "initial contents".to_string();\n')])])]),a("h2",{attrs:{id:"更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let mut s1 = String::from("foo");\nlet s2 = "bar";\ns1.push_str(s2);\nprintln!("s2 is {}", s2);\n\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let s1 = String::from("Hello, ");\nlet s2 = String::from("world!");\nlet s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用\n')])])]),a("h2",{attrs:{id:"拼接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拼接"}},[t._v("#")]),t._v(" 拼接")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let s1 = String::from("tic");\nlet s2 = String::from("tac");\nlet s3 = String::from("toe");\n\nlet s = format!("{}-{}-{}", s1, s2, s3);\n')])])]),a("h2",{attrs:{id:"内部表现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部表现"}},[t._v("#")]),t._v(" 内部表现")]),t._v(" "),a("p",[t._v("String 是一个 "),a("code",[t._v("Vec<u8>")]),t._v(" 的封装")]),t._v(" "),a("h2",{attrs:{id:"slice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slice"}},[t._v("#")]),t._v(" slice")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let hello = "Здравствуйте";\n\nlet s = &hello[0..4];\n')])])]),a("h2",{attrs:{id:"遍历-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历-2"}},[t._v("#")]),t._v(" 遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('for c in "नमस्ते".chars() {\n    println!("{}", c);\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('for b in "नमस्ते".bytes() {\n    println!("{}", b);\n}\n')])])]),a("h1",{attrs:{id:"hashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet teams  = vec![String::from("Blue"), String::from("Yellow")];\nlet initial_scores = vec![10, 50];\n\nlet scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();\n')])])]),a("h2",{attrs:{id:"所有权"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权"}},[t._v("#")]),t._v(" 所有权")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet field_name = String::from("Favorite color");\nlet field_value = String::from("Blue");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// 这里 field_name 和 field_value 不再有效，\n// 尝试使用它们看看会出现什么编译错误！\n')])])]),a("h2",{attrs:{id:"访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问"}},[t._v("#")]),t._v(" 访问")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\n\nlet team_name = String::from("Blue");\nlet score = scores.get(&team_name);\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\n\nfor (key, value) in &scores {\n    println!("{}: {}", key, value);\n}\n\n')])])]),a("h2",{attrs:{id:"插入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from("Blue"), 10);\n\nscores.entry(String::from("Yellow")).or_insert(50);\nscores.entry(String::from("Blue")).or_insert(50);\n\nprintln!("{:?}", scores);\n')])])]),a("h2",{attrs:{id:"更新-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新-2"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\nuse std::collections::HashMap;\n\nlet text = "hello world wonderful world";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\n\nprintln!("{:?}", map);\n')])])]),a("h2",{attrs:{id:"根据旧值更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#根据旧值更新"}},[t._v("#")]),t._v(" 根据旧值更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::collections::HashMap;\n\nlet text = "hello world wonderful world";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    // 解引用\n    *count += 1;\n}\n\nprintln!("{:?}", map);\n')])])]),a("h1",{attrs:{id:"painic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#painic"}},[t._v("#")]),t._v(" painic")]),t._v(" "),a("p",[t._v("有的时候代码出问题了，而你对此束手无策。对于这种情况，Rust 有 panic!宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug，而且开发者并不清楚该如何处理它。")]),t._v(" "),a("h2",{attrs:{id:"result"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#result"}},[t._v("#")]),t._v(" Result")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::fs::File;\n\nfn main() {\n    let f = File::open("hello.txt");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => {\n            panic!("Problem opening the file: {:?}", error)\n        },\n    };\n}\n')])])]),a("h2",{attrs:{id:"unwrap-和expect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unwrap-和expect"}},[t._v("#")]),t._v(" unwrap 和expect")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::fs::File;\n\nfn main() {\n    let f = File::open("hello.txt").unwrap();\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::fs::File;\n\nfn main() {\n    let f = File::open("hello.txt").expect("Failed to open hello.txt");\n}\n\n')])])]),a("h2",{attrs:{id:"传播错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传播错误"}},[t._v("#")]),t._v(" 传播错误")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let f = File::open("hello.txt");\n\n    let mut f = match f {\n        Ok(file) => file,\n        Err(e) => return Err(e),\n    };\n\n    let mut s = String::new();\n\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n')])])]),a("h2",{attrs:{id:"传播简写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传播简写"}},[t._v("#")]),t._v(" 传播简写 ?")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('use std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut f = File::open("hello.txt")?;\n    let mut s = String::new();\n    f.read_to_string(&mut s)?;\n    Ok(s)\n}\n')])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("Rust 的错误处理功能旨在帮助你编写更健壮的代码。panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 Result 来告诉代码调用者他需要处理潜在的成功或失败。在适当的场景使用 panic! 和 Result 将会使你的代码在面对不可避免的错误时显得更加可靠。")]),t._v(" "),a("p",[t._v("现在我们已经见识过了标准库中 Option 和 Result 泛型枚举的能力了，在下一章让我们来聊聊泛型是如何工作的，以及如何在你的代码中使用它们。")]),t._v(" "),a("h1",{attrs:{id:"泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),a("h2",{attrs:{id:"函数-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数-2"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn largest<T>(list: &[T]) -> T {\n    let mut largest = list[0];\n\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n")])])]),a("h2",{attrs:{id:"结构体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[t._v("#")]),t._v(" 结构体")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n")])])]),a("h2",{attrs:{id:"枚举-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举-2"}},[t._v("#")]),t._v(" 枚举")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n")])])]),a("h2",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('struct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!("p.x = {}", p.x());\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('struct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nimpl<T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: "Hello", y: \'c\'};\n\n    let p3 = p1.mixup(p2);\n\n    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);\n}\n')])])]),a("h2",{attrs:{id:"单态化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单态化"}},[t._v("#")]),t._v(" 单态化")]),t._v(" "),a("p",[t._v("填充编译时具体的类型, 转化为特定代码")]),t._v(" "),a("h1",{attrs:{id:"trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trait"}},[t._v("#")]),t._v(" trait")]),t._v(" "),a("p",[t._v("trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。\n有点像其他语言的接口")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("pub trait Summary {\n    fn summarize(&self) -> String;\n}\n")])])]),a("h2",{attrs:{id:"类型实现trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型实现trait"}},[t._v("#")]),t._v(" 类型实现trait")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('pub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!("{}, by {} ({})", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!("{}: {}", self.username, self.content)\n    }\n}\n')])])]),a("h2",{attrs:{id:"默认实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认实现"}},[t._v("#")]),t._v(" 默认实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('pub trait Summary {\n    fn summarize(&self) -> String {\n        String::from("(Read more...)")\n    }\n}\n')])])]),a("h2",{attrs:{id:"trait作为参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trait作为参数"}},[t._v("#")]),t._v(" trait作为参数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('pub fn notify(item: impl Summary) {\n    println!("Breaking news! {}", item.summarize());\n}\n')])])]),a("h2",{attrs:{id:"指定多个trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指定多个trait"}},[t._v("#")]),t._v(" + 指定多个trait")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("pub fn notify(item: impl Summary + Display) {\n")])])]),a("h2",{attrs:{id:"where"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#where"}},[t._v("#")]),t._v(" where")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn some_function<T, U>(t: T, u: U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{\n\n// 等价\n\n fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {\n")])])]),a("h2",{attrs:{id:"return"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#return"}},[t._v("#")]),t._v(" return")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from("horse_ebooks"),\n        content: String::from("of course, as you probably already know, people"),\n        reply: false,\n        retweet: false,\n    }\n}\n')])])]),a("h2",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[t._v("#")]),t._v(" example")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("n largest<T: PartialOrd + Copy>(list: &[T]) -> T {\n    let mut largest = list[0];\n\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n")])])]),a("h1",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[t._v("Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。")]),t._v(" "),a("h2",{attrs:{id:"借用检查器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#借用检查器"}},[t._v("#")]),t._v(" 借用检查器")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n")])])]),a("p",[t._v("这里将 r 的生命周期标记为 'a 并将 x 的生命周期标记为 'b。如你所见，内部的 'b 块要比外部的生命周期 'a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。")]),t._v(" "),a("h2",{attrs:{id:"生命周期标注语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期标注语法"}},[t._v("#")]),t._v(" 生命周期标注语法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("&i32        // 引用\n&'a i32     // 带有显式生命周期的引用\n&'a mut i32 // 带有显式生命周期的可变引用\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")])])]),a("h1",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn generate_workout(intensity: u32, random_number: u32) {\n    let expensive_closure = |num| {\n        println!("calculating slowly...");\n        thread::sleep(Duration::from_secs(2));\n        num\n    };\n\n    if intensity < 25 {\n        println!(\n            "Today, do {} pushups!",\n            expensive_closure(intensity)\n        );\n        println!(\n            "Next, do {} situps!",\n            expensive_closure(intensity)\n        );\n    } else {\n        if random_number == 3 {\n            println!("Take a break today! Remember to stay hydrated!");\n        } else {\n            println!(\n                "Today, run for {} minutes!",\n                expensive_closure(intensity)\n            );\n        }\n    }\n}\n\n')])])]),a("h2",{attrs:{id:"lazy-avaluation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy-avaluation"}},[t._v("#")]),t._v(" lazy avaluation")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    calculation: T,\n    value: Option<u32>,\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("impl<T> Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    fn new(calculation: T) -> Cacher<T> {\n        Cacher {\n            calculation,\n            value: None,\n        }\n    }\n\n    fn value(&mut self, arg: u32) -> u32 {\n        match self.value {\n            Some(v) => v,\n            None => {\n                let v = (self.calculation)(arg);\n                self.value = Some(v);\n                v\n            },\n        }\n    }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn main() {\n    let x = 4;\n\n    let equal_to_x = |z| z == x;\n\n    let y = 4;\n\n    assert!(equal_to_x(y));\n}\n")])])]),a("h2",{attrs:{id:"捕获环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获环境"}},[t._v("#")]),t._v(" 捕获环境")]),t._v(" "),a("ul",[a("li",[t._v("FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。")]),t._v(" "),a("li",[t._v("FnMut 获取可变的借用值所以可以改变其环境")]),t._v(" "),a("li",[t._v("Fn 从其环境获取不可变的借用值")])]),t._v(" "),a("h2",{attrs:{id:"move"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#move"}},[t._v("#")]),t._v(" move")]),t._v(" "),a("p",[t._v("获取所有权")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let x = vec![1, 2, 3];\n\n    let equal_to_x = move |z| z == x;\n\n    println!("can\'t use x here: {:?}", x);\n\n    let y = vec![1, 2, 3];\n\n    assert!(equal_to_x(y));\n}\n\n')])])]),a("h1",{attrs:{id:"迭代器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[t._v("#")]),t._v(" 迭代器")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!("Got: {}", val);\n}\n')])])]),a("p",[t._v("迭代器的实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("pub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // 此处省略了方法的默认实现\n}\n")])])]),a("h2",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" map")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n")])])]),a("h2",{attrs:{id:"闭包获取环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包获取环境"}},[t._v("#")]),t._v(" 闭包获取环境")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter()\n        .filter(|s| s.size == shoe_size)\n        .collect()\n}\n\n#[test]\nfn filters_by_size() {\n    let shoes = vec![\n        Shoe { size: 10, style: String::from("sneaker") },\n        Shoe { size: 13, style: String::from("sandal") },\n        Shoe { size: 10, style: String::from("boot") },\n    ];\n\n    let in_my_size = shoes_in_my_size(shoes, 10);\n\n    assert_eq!(\n        in_my_size,\n        vec![\n            Shoe { size: 10, style: String::from("sneaker") },\n            Shoe { size: 10, style: String::from("boot") },\n        ]\n    );\n}\n')])])]),a("h1",{attrs:{id:"box"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#box"}},[t._v("#")]),t._v(" Box"),a("T")],1),t._v(" "),a("p",[t._v("box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n   let b = Box::new(5);\n   println!("b = {}", b);\n}\n\n')])])]),a("h1",{attrs:{id:"解引用-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解引用-2"}},[t._v("#")]),t._v(" 解引用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn main() {\n   let x = 5;\n   let y = &x;\n\n   assert_eq!(5, x);\n   assert_eq!(5, *y);\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("*y 等价于 *(y.deref())\n")])])]),a("h2",{attrs:{id:"解引用强制转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解引用强制转换"}},[t._v("#")]),t._v(" 解引用强制转换")]),t._v(" "),a("p",[t._v("Rust 在函数或方法传参上的一种便利。解引用强制转换只能工作在实现了 Deref trait 的类型上。解引用强制转换将一种类型（A）隐式转换为另外一种类型（B）的引用，因为 A 类型实现了 Deref trait，并且其关联类型是 B 类型。比如，解引用强制转换可以将 &String 转换为 &str，因为类型 String 实现了 Deref trait 并且其关联类型是 str")]),t._v(" "),a("p",[t._v("当我们将特定类型的值的引用作为参数传递给函数或方法，但是被传递的值的引用与函数或方法中定义的参数类型不匹配时，会发生解引用强制转换。这时会有一系列的 deref 方法被调用，把我们提供的参数类型转换成函数或方法需要的参数类型。")]),t._v(" "),a("h2",{attrs:{id:"解引用强制转换-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解引用强制转换-2"}},[t._v("#")]),t._v(" 解引用强制转换")]),t._v(" "),a("ul",[a("li",[t._v("当 T: Deref<Target=U> ：从 &T 到 &U。")]),t._v(" "),a("li",[t._v("当 T: DerefMut<Target=U> ：从 &mut T 到 &mut U。")]),t._v(" "),a("li",[t._v("当 T: Deref<Target=U> ：从 &mut T 到 &U。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);